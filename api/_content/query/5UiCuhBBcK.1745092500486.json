{"_path":"/articles/algo-vertretung-14-04-25","_dir":"articles","_draft":false,"_partial":false,"_locale":"","title":"Traveling Salesman Problem (TSP)","description":"Brute-Force, Nearest Neighbor, and christofilf algorithm | Traveling Salesman Problem (TSP)","cover":null,"author":{"name":"Marc Nauendorf","avatarUrl":"https://pbs.twimg.com/profile_images/1042510623962275840/1Iw_Mvud_400x400.jpg"},"date":"2025-04-23T00:00:00.000Z","layout":"page","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"traveling-salesman-problem-tsp"},"children":[{"type":"text","value":"Traveling Salesman Problem (TSP)"}]},{"type":"element","tag":"iframe","props":{"src":"https://docs.google.com/viewer?url=https://github.com/Nr44suessauer/nr44suessauer.github.io/raw/main/nuxt-app/assets/Presentation_with_marp/Algo_14.04.2025.pdf&embedded=true","style":"width:100%; height:500px; border:none;"},"children":[]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"div","props":{"className":["notebook-container"],"style":"margin-top: 20px; margin-bottom: 20px;"},"children":[{"type":"text","value":"\n    "},{"type":"element","tag":"details","props":{},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"summary","props":{"style":"cursor: pointer; font-weight: bold; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px;"},"children":[{"type":"text","value":"\n            Jupyter Notebook: SalesMan Problem Neuste & Complete Version (Click to Show/Hide)\n        "}]},{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"style":"border: 1px solid #ddd; padding: 15px; margin-top: 10px; background-color: #f9f9f9;"},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"iframe","props":{"src":"https://nbviewer.org/github/Nr44suessauer/SalesMan/blob/main/SalesMan_Problem.ipynb","width":"100%","height":800,"style":"border: none;","allowFullScreen":true},"children":[{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"p","props":{"style":"text-align: center; margin-top: 10px;"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"a","props":{"href":"https://github.com/Nr44suessauer/SalesMan/blob/main/SalesMan_Problem.ipynb","target":"_blank"},"children":[{"type":"text","value":"\n                    Open Notebook on GitHub\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]}]},{"type":"element","tag":"title","props":{},"children":[{"type":"text","value":"Algorithm Animations"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":"\n        /* Common styles */\n        canvas {\n            border: 1px solid black;\n            display: block;\n        }   \n        /* Christofides styles */\n        .container {\n            display: flex;\n        }\n        .animation-container {\n            flex: 1;\n        }\n        #infoPanel {\n            flex: 0 0 500px;\n            margin-left: 20px;\n            background: #f2f2f2;\n            padding: 10px;\n            font-family: sans-serif;\n            font-size: 14px;\n            overflow-y: auto;\n            max-height: 900px;\n        }\n        .controls > div {\n            margin: 10px 0;\n        }\n        .controls > div > * {\n            margin-right: 10px;\n        }\n        #speedSlider,\n        #numPoints {\n            transform: scale(1);\n            transform-origin: left center;\n        }     \n        /* Nearest Neighbor styles */\n        .nn-container {\n            display: flex;\n        }\n        .nn-animation-container {\n            flex: 1;\n        }\n        #nnInfoPanel {\n            flex: 0 0 500px;\n            margin-left: 20px;\n            background: #f2f2f2;\n            padding: 10px;\n            font-family: sans-serif;\n            font-size: 14px;\n            overflow-y: auto;\n            max-height: 900px;\n        }\n        #nnCanvas {\n            border: 1px solid black;\n            display: block;\n        }\n        .nn-controls > div {\n            margin: 10px 0;\n        }\n        .nn-controls > div > * {\n            margin-right: 10px;\n        }\n        .selection-table {\n            width: 100%;\n            border-collapse: collapse;\n            margin: 10px 0;\n        }\n        .selection-table th, .selection-table td {\n            border: 1px solid #ddd;\n            padding: 4px;\n            text-align: center;\n        }\n        .selection-table .selected {\n            background-color: #d4ffd4;\n            font-weight: bold;\n        }\n        /* Dark Mode anpassungen für Tabellen */\n        @media (prefers-color-scheme: dark) {\n            .selection-table th, .selection-table td {\n                border-color: #555;\n            }\n            .selection-table .selected {\n                background-color: #2a472a;\n                font-weight: bold;\n            }\n            /* Verbesserte Sichtbarkeit für den Haken im Dark Mode */\n            .selection-table td:last-child {\n                color: #fff;\n            }\n            /* Hervorgehobene Markierung für den kürzesten Pfad */\n            .selection-table .selected td:last-child {\n                color: #4CAF50;\n                font-size: 1.2em;\n                font-weight: bold;\n            }\n            /* Verbesserte Sichtbarkeit für die Jupyter Notebook Buttons im Dark Mode */\n            .notebook-container details summary, \n            details.notebook-details summary, \n            body.dark-mode .notebook-container details summary,\n            body.dark-theme .notebook-container details summary {\n                background-color: #444 !important;\n                color: #fff !important;\n                border-color: #666 !important;\n            }\n        }\n        /* Brute Force styles */\n        .bf-container {\n            display: flex;\n        }\n        .bf-animation-container {\n            flex: 1;\n        }\n        #bfInfoPanel {\n            flex: 0 0 500px;\n            margin-left: 20px;\n            background: #f2f2f2;\n            padding: 10px;\n            font-family: sans-serif;\n            font-size: 14px;\n            overflow-y: auto;\n            max-height: 900px;\n        }\n        #bfCanvas {\n            border: 1px solid black;\n            display: block;\n        }\n        .bf-controls > div {\n            margin: 10px 0;\n        }\n        .bf-controls > div > * {\n            margin-right: 10px;\n        }\n    "}]},{"type":"element","tag":"h3","props":{"id":"brute-force-algorithm"},"children":[{"type":"text","value":"Brute Force Algorithm"}]},{"type":"element","tag":"div","props":{"className":["bf-container"]},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"className":["bf-animation-container"]},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"className":["bf-controls"]},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Next Step"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{"style":"background-color: #ff5555; color: white;"},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Start/Stop Animation"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["bfSpeedSlider"]},"children":[{"type":"text","value":"Speed:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"range","id":"bfSpeedSlider","min":"50","max":"4000","step":"1","value":"300"},"children":[]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["bfNumPoints"]},"children":[{"type":"text","value":"Number of points:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"bfNumPoints","min":"3","max":"25","value":"4","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Random Points"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Import Christofides Points"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Import NN-Points"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["bfStartPoint"]},"children":[{"type":"text","value":"Start point:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"bfStartPoint","min":"0","max":"24","value":"0","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Set Start Point"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"select","props":{"id":"bfConstellationSelect","style":"height:30px;"},"children":[{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":""},"children":[{"type":"text","value":"Choose constellation..."}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"libra"},"children":[{"type":"text","value":"Libra - 10 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"orion"},"children":[{"type":"text","value":"Orion - 10 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"ursa_minor"},"children":[{"type":"text","value":"Ursa Minor - 7 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cassiopeia"},"children":[{"type":"text","value":"Cassiopeia - 5 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cygnus"},"children":[{"type":"text","value":"Cygnus - 9 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"ursa_major"},"children":[{"type":"text","value":"Ursa Major - 7 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"leo"},"children":[{"type":"text","value":"Leo - 9 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"draco"},"children":[{"type":"text","value":"Draco - 11 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"gemini"},"children":[{"type":"text","value":"Gemini - 9 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"southern_cross"},"children":[{"type":"text","value":"Southern Cross - 4 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pegasus"},"children":[{"type":"text","value":"Pegasus - 5 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"andromeda"},"children":[{"type":"text","value":"Andromeda - 7 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"sagittarius"},"children":[{"type":"text","value":"Sagittarius - 8 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"scorpius"},"children":[{"type":"text","value":"Scorpius - 10 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cancer"},"children":[{"type":"text","value":"Cancer - 6 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pisces"},"children":[{"type":"text","value":"Pisces - 11 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"aquila"},"children":[{"type":"text","value":"Aquila - 7 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"hercules"},"children":[{"type":"text","value":"Hercules - 8 points"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"myrtana"},"children":[{"type":"text","value":"Myrtana - 5 Punkte"}]},{"type":"text","value":"\n                    "}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Download Graph"}]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"canvas","props":{"id":"bfCanvas","width":800,"height":600},"children":[]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"id":"bfInfoPanel"},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"h3","props":{"id":"brute-force-data"},"children":[{"type":"text","value":"Brute Force Data"}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"bfDataOutput"},"children":[{"type":"text","value":"Waiting for the first step..."}]},{"type":"text","value":"\n            "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Show/Hide Table"}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"bfFullTable","style":"display: none; margin-top: 20px;"},"children":[]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"div","props":{"className":["notebook-container"],"style":"margin-top: 20px; margin-bottom: 20px;"},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"details","props":{},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"summary","props":{"style":"cursor: pointer; font-weight: bold; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px;"},"children":[{"type":"text","value":"\n                Jupyter Notebook: Brute Force TSP Implementation (Click to Show/Hide)\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"style":"border: 1px solid #ddd; padding: 15px; margin-top: 10px; background-color: #f9f9f9;"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"iframe","props":{"src":"https://nbviewer.org/github/Nr44suessauer/SalesMan/blob/main/BruteForce_TSP.ipynb","width":"100%","height":800,"style":"border: none;","allowFullScreen":true},"children":[{"type":"text","value":"\n                "}]},{"type":"text","value":"\n                "},{"type":"element","tag":"p","props":{"style":"text-align: center; margin-top: 10px;"},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"a","props":{"href":"https://github.com/Nr44suessauer/SalesMan/blob/main/BruteForce_TSP.ipynb","target":"_blank"},"children":[{"type":"text","value":"\n                        Open Notebook on GitHub\n                    "}]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"div","props":{"style":"display: flex; align-items: center; margin-top: 30px;"},"children":[]},{"type":"element","tag":"div","props":{"style":"display: flex; align-items: center; margin-top: 10px;"},"children":[]},{"type":"element","tag":"h3","props":{"id":"nearest-neighbor-algorithm"},"children":[{"type":"text","value":"Nearest Neighbor Algorithm"}]},{"type":"element","tag":"div","props":{"className":["nn-container"]},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"className":["nn-animation-container"]},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"className":["nn-controls"]},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Nächster Schritt"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{"style":"background-color: #ff5555; color: white;"},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Animation Start/Stop"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["nnSpeedSlider"]},"children":[{"type":"text","value":"Geschwindigkeit:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"range","id":"nnSpeedSlider","min":"50","max":"4000","step":"1","value":"300"},"children":[]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["nnNumPoints"]},"children":[{"type":"text","value":"Anzahl der Punkte:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"nnNumPoints","min":"3","max":"25","value":"4","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Zufällige Punkte"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Christofides Punkte importieren"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"BF-Punkte importieren"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["nnStartPoint"]},"children":[{"type":"text","value":"Startpunkt:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"nnStartPoint","min":"0","max":"24","value":"0","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Startpunkt setzen"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{"style":"background-color: #4CAF50; color: white;"},"children":[{"type":"text","value":"Besten Startpunkt finden"}]},{"type":"text","value":"\n                    "},{"type":"text","value":"\n                    "},{"type":"element","tag":"select","props":{"id":"nnConstellationSelect","style":"height:30px;"},"children":[{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":""},"children":[{"type":"text","value":"Sternenbild wählen..."}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"libra"},"children":[{"type":"text","value":"Waage (Libra) - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"orion"},"children":[{"type":"text","value":"Orion - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"ursa_minor"},"children":[{"type":"text","value":"Kleiner Bär - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cassiopeia"},"children":[{"type":"text","value":"Kassiopeia - 5 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cygnus"},"children":[{"type":"text","value":"Schwan - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"ursa_major"},"children":[{"type":"text","value":"Großer Bär - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"leo"},"children":[{"type":"text","value":"Löwe - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"draco"},"children":[{"type":"text","value":"Drache - 11 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"gemini"},"children":[{"type":"text","value":"Zwillinge - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"southern_cross"},"children":[{"type":"text","value":"Kreuz des Südens - 4 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pegasus"},"children":[{"type":"text","value":"Pegasus - 5 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"andromeda"},"children":[{"type":"text","value":"Andromeda - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"sagittarius"},"children":[{"type":"text","value":"Schütze - 8 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"scorpius"},"children":[{"type":"text","value":"Skorpion - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cancer"},"children":[{"type":"text","value":"Krebs - 6 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pisces"},"children":[{"type":"text","value":"Fische - 11 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"aquila"},"children":[{"type":"text","value":"Adler - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"hercules"},"children":[{"type":"text","value":"Herkules - 8 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"myrtana"},"children":[{"type":"text","value":"Myrtana - 5 Punkte"}]},{"type":"text","value":"\n                    "}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Graph herunterladen"}]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"canvas","props":{"id":"nnCanvas","width":800,"height":600},"children":[]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"id":"nnInfoPanel"},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"h3","props":{"id":"nearest-neighbor-daten"},"children":[{"type":"text","value":"Nearest Neighbor Daten"}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"nnDataOutput"},"children":[{"type":"text","value":"Warte auf den ersten Schritt..."}]},{"type":"text","value":"\n            "},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"text","value":"\n            "},{"type":"element","tag":"label","props":{"htmlFor":["nnStepDropdown"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Schritte:"}]}]},{"type":"text","value":"\n            "},{"type":"element","tag":"select","props":{"id":"nnStepDropdown"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"option","props":{"value":""},"children":[{"type":"text","value":"Schritt auswählen..."}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Tabelle ein-/ausblenden"}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"nnStepDetails"},"children":[]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"nnFullTable","style":"display: none; margin-top: 20px;"},"children":[]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"div","props":{"className":["notebook-container"],"style":"margin-top: 20px; margin-bottom: 20px;"},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"details","props":{},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"summary","props":{"style":"cursor: pointer; font-weight: bold; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px;"},"children":[{"type":"text","value":"\n                Jupyter Notebook: Nearest Neighbor TSP Implementation (Klicken zum Anzeigen/Ausblenden)\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"style":"border: 1px solid #ddd; padding: 15px; margin-top: 10px; background-color: #f9f9f9; width: 100%;"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"iframe","props":{"src":"https://nbviewer.org/github/Nr44suessauer/SalesMan/blob/main/NearestNeighbor_TSP.ipynb","width":"100%","height":800,"style":"border: none;","allowFullScreen":true},"children":[{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"     "},{"type":"element","tag":"p","props":{"style":"text-align: center; margin-top: 10px;"},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"a","props":{"href":"https://github.com/Nr44suessauer/SalesMan/blob/main/NearestNeighbor_TSP.ipynb","target":"_blank"},"children":[{"type":"text","value":"\n                        Notebook auf GitHub öffnen\n                    "}]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"div","props":{"style":"display: flex; align-items: center; margin-top: 30px;"},"children":[]},{"type":"element","tag":"div","props":{"style":"display: flex; align-items: center; margin-top: 10px;"},"children":[]},{"type":"element","tag":"h3","props":{"id":"christofides-algorithm"},"children":[{"type":"text","value":"Christofides Algorithm"}]},{"type":"element","tag":"div","props":{"className":["container"]},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"className":["animation-container"]},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"className":["controls"]},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Nächster Schritt"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{"style":"background-color: #ff5555; color: white;"},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Animation Start/Stop"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["speedSlider"]},"children":[{"type":"text","value":"Geschwindigkeit:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"range","id":"speedSlider","min":"50","max":"4000","step":"1","value":"300"},"children":[]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n                "},{"type":"element","tag":"div","props":{},"children":[{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["numPoints"]},"children":[{"type":"text","value":"Anzahl der Punkte:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"numPoints","min":"3","max":"25","value":"4","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Zufällige Punkte"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"NN-Punkte importieren"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"BF-Punkte importieren"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"label","props":{"htmlFor":["startPointChristofides"]},"children":[{"type":"text","value":"Startpunkt:"}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"input","props":{"type":"number","id":"startPointChristofides","min":"0","max":"24","value":"0","style":"width:50px; height:30px;"},"children":[]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Startpunkt setzen"}]},{"type":"text","value":"\n                    "},{"type":"text","value":"\n                    "},{"type":"element","tag":"select","props":{"id":"constellationSelect","style":"height:30px;"},"children":[{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":""},"children":[{"type":"text","value":"Sternenbild wählen..."}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"libra"},"children":[{"type":"text","value":"Waage (Libra) - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"orion"},"children":[{"type":"text","value":"Orion - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cassiopeia"},"children":[{"type":"text","value":"Kassiopeia - 5 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cygnus"},"children":[{"type":"text","value":"Schwan - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"ursa_major"},"children":[{"type":"text","value":"Großer Bär - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"leo"},"children":[{"type":"text","value":"Löwe - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"draco"},"children":[{"type":"text","value":"Drache - 11 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"gemini"},"children":[{"type":"text","value":"Zwillinge - 9 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"southern_cross"},"children":[{"type":"text","value":"Kreuz des Südens - 4 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pegasus"},"children":[{"type":"text","value":"Pegasus - 5 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"andromeda"},"children":[{"type":"text","value":"Andromeda - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"sagittarius"},"children":[{"type":"text","value":"Schütze - 8 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"scorpius"},"children":[{"type":"text","value":"Skorpion - 10 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"cancer"},"children":[{"type":"text","value":"Krebs - 6 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"pisces"},"children":[{"type":"text","value":"Fische - 11 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"aquila"},"children":[{"type":"text","value":"Adler - 7 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"hercules"},"children":[{"type":"text","value":"Herkules - 8 Punkte"}]},{"type":"text","value":"\n                        "},{"type":"element","tag":"option","props":{"value":"myrtana"},"children":[{"type":"text","value":"Myrtana - 5 Punkte"}]},{"type":"text","value":"\n                    "}]},{"type":"text","value":"\n                    "},{"type":"element","tag":"button","props":{},"children":[{"type":"text","value":"Graph herunterladen"}]},{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"canvas","props":{"id":"canvas","width":800,"height":600},"children":[]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n        "},{"type":"element","tag":"div","props":{"id":"infoPanel"},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"h3","props":{"id":"christofides-algorithm-daten"},"children":[{"type":"text","value":"Christofides Algorithm Daten"}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"id":"dataOutput"},"children":[{"type":"text","value":"Warte auf den ersten Schritt..."}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"div","props":{"className":["notebook-container"],"style":"margin-top: 20px; margin-bottom: 20px;"},"children":[{"type":"text","value":"\n        "},{"type":"element","tag":"details","props":{},"children":[{"type":"text","value":"\n            "},{"type":"element","tag":"summary","props":{"style":"cursor: pointer; font-weight: bold; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px;"},"children":[{"type":"text","value":"\n                Jupyter Notebook: Christofides TSP Implementation (Klicken zum Anzeigen/Ausblenden)\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"div","props":{"style":"border: 1px solid #ddd; padding: 15px; margin-top: 10px; background-color: #f9f9f9; width: 100%;"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"iframe","props":{"src":"https://nbviewer.org/github/Nr44suessauer/SalesMan/blob/main/Christofides_TSP.ipynb","width":"100%","height":800,"style":"border: none;","allowFullScreen":true},"children":[{"type":"text","value":"\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n            "},{"type":"element","tag":"p","props":{"style":"text-align: center; margin-top: 10px;"},"children":[{"type":"text","value":"\n                "},{"type":"element","tag":"a","props":{"href":"https://github.com/Nr44suessauer/SalesMan/blob/main/Christofides_TSP.ipynb","target":"_blank"},"children":[{"type":"text","value":"\n                    Notebook auf GitHub öffnen\n                "}]},{"type":"text","value":"\n            "}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n    "}]},{"type":"element","tag":"script","props":{},"children":[{"type":"text","value":"\n    // Funktion zur Erkennung des Dark Mode\n    function isDarkMode() {\n        return document.documentElement.getAttribute('data-theme-setting') === \"dark\" ||\n            (document.documentElement.getAttribute('data-theme-setting') === null && \n             window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);\n    }\n// Funktion zur Bestimmung der Koordinatensystemfarbe basierend auf dem Theme\n\n// Funktion zur Bestimmung der Koordinatensystemfarbe basierend auf dem Theme\nfunction getGridColor() {\n    // Im Light Mode die Standardfarbe verwenden\n    return isDarkMode() ? \"#999\" : \"#ccc\";\n}\n\n// Funktion zur Bestimmung der Textfarbe basierend auf dem Theme\nfunction getTextColor() {\n    // Im Light Mode die Standardfarbe \"black\" verwenden\n    return isDarkMode() ? \"#fff\" : \"black\";\n}\n\n// Funktion zur Bestimmung der Punktfarbe basierend auf dem Theme\nfunction getPointColor() {\n    // Explizit schwarz im Light Mode, weiß im Dark Mode\n    return isDarkMode() ? \"#ffffff\" : \"#000000\";\n}\n\n// Funktion zur Anpassung der Info-Panels basierend auf dem Theme\nfunction updateInfoPanelsStyle() {\n    const isDark = isDarkMode();\n    const panels = [\n        document.getElementById('infoPanel'),\n        document.getElementById('nnInfoPanel'),\n        document.getElementById('bfInfoPanel')\n    ];\n    \n    panels.forEach(panel => {\n        if (panel) {\n            if (isDark) {\n                // Im Dark Mode dunklerer Hintergrund und heller Text\n                panel.style.backgroundColor = \"#222\";\n                panel.style.color = \"#fff\";\n                // Tabellenfarben im Dark Mode anpassen\n                const tables = panel.querySelectorAll('table');\n                tables.forEach(table => {\n                    table.style.borderColor = \"#555\";\n                    const cells = table.querySelectorAll('td, th');\n                    cells.forEach(cell => {\n                        cell.style.borderColor = \"#555\";\n                    });\n                });\n            } else {\n                // Im Light Mode heller Hintergrund und dunkler Text\n                panel.style.backgroundColor = \"#f2f2f2\";\n                panel.style.color = \"#000\"; \n                // Standardstile für Tabellen wiederherstellen\n                const tables = panel.querySelectorAll('table');\n                tables.forEach(table => {\n                    table.style.borderColor = \"#ddd\";\n                    const cells = table.querySelectorAll('td, th');\n                    cells.forEach(cell => {\n                        cell.style.borderColor = \"#ddd\";\n                    });\n                });\n            }\n            \n            // Sicherstellen, dass die Änderungen übernommen werden\n            panel.style.transition = \"background-color 0.3s, color 0.3s\";\n        }\n    });\n}\n\n// Direkte Ausführung nach dem Laden - außerhalb des DOMContentLoaded-Events\n(function immediateStyleUpdate() {\n    // Sofortige Ausführung der Stilanpassungen\n    setTimeout(function() {\n        updateInfoPanelsStyle();\n        \n        // Stellen Sie sicher, dass die Canvas-Elemente korrekt gezeichnet werden\n        if (animation) {\n            animation.ctx.clearRect(0, 0, 100, 50);\n            animation.drawNodes(true);\n        }\n        if (nnAnimation) {\n            nnAnimation.ctx.clearRect(0, 0, 100, 50);\n            nnAnimation.drawNodes(true);\n        }\n        if (bfAnimation) {\n            bfAnimation.ctx.clearRect(0, 0, 50, 50);\n            bfAnimation.drawNodes(true);\n        }\n    }, 100);\n})();\n\n// Theme-Anpassungen beim Laden der Seite und bei Änderungen durchführen\ndocument.addEventListener('DOMContentLoaded', function() {\n    updateInfoPanelsStyle();\n    \n    // Beobachte Theme-Änderungen\n    if (window.matchMedia) {\n        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function() {\n            updateInfoPanelsStyle();\n            \n            // Nach Änderung des Themes neu zeichnen\n            if (animation) {\n                animation.ctx.clearRect(0, 0, 100, 50);\n                animation.drawNodes(true);\n            }\n            if (nnAnimation) {\n                nnAnimation.ctx.clearRect(0, 0, 100, 50);\n                nnAnimation.drawNodes(true);\n            }\n            if (bfAnimation) {\n                bfAnimation.ctx.clearRect(0, 0, 50, 50);\n                bfAnimation.drawNodes(true);\n            }\n        });\n    }\n});\n\n// Gemeinsame Konstante für die Sternbildkoordinaten\nconst CONSTELLATIONS = {\n    // Waage (Libra)\n    libra: [\n        { x: 21, y: 5 },\n        { x: 13, y: 13 },\n        { x: 5, y: 21 },\n        { x: 13, y: 29 },\n        { x: 21, y: 29 },\n        { x: 29, y: 29 },\n        { x: 37, y: 21 },\n        { x: 29, y: 13 },\n        { x: 21, y: 21 },\n        { x: 29, y: 37 }\n    ],\n    // Orion (Der Jäger)\n    orion: [\n        { x: 21, y: 5 },\n        { x: 13, y: 13 },\n        { x: 5, y: 21 },\n        { x: 13, y: 29 },\n        { x: 21, y: 29 },\n        { x: 29, y: 29 },\n        { x: 37, y: 21 },\n        { x: 29, y: 13 },\n        { x: 21, y: 37 },\n        { x: 21, y: 45 }\n    ],\n    // Kleiner Wagen (Ursa Minor)\n    ursa_minor: [\n        { x: 15, y: 15 },\n        { x: 13, y: 25 },\n        { x: 21, y: 29 },\n        { x: 25, y: 35 },\n        { x: 35, y: 39 },\n        { x: 45, y: 45 },\n        { x: 39, y: 25 }\n    ],\n    // Kassiopeia (W-Form)\n    cassiopeia: [\n        { x: 7, y: 10 },\n        { x: 13, y: 25 },\n        { x: 21, y: 10 },\n        { x: 33, y: 25 },\n        { x: 43, y: 10 }\n    ],\n    // Schwan (Cygnus/Nördliches Kreuz)\n    cygnus: [\n        { x: 25, y: 5 },\n        { x: 25, y: 13 },\n        { x: 25, y: 21 },\n        { x: 25, y: 29 },\n        { x: 25, y: 45 },\n        { x: 5, y: 21 },\n        { x: 13, y: 21 },\n        { x: 37, y: 21 },\n        { x: 45, y: 21 }\n    ],\n    // Großer Wagen (Ursa Major)\n    ursa_major: [\n        { x: 5, y: 5 },\n        { x: 13, y: 15 },\n        { x: 21, y: 20 },\n        { x: 30, y: 25 },\n        { x: 35, y: 35 },\n        { x: 40, y: 45 }\n    ],\n    // Löwe (Leo)\n    leo: [\n        { x: 10, y: 10 },\n        { x: 15, y: 15 },\n        { x: 25, y: 20 },\n        { x: 35, y: 25 },\n        { x: 45, y: 30 },\n        { x: 35, y: 35 },\n        { x: 25, y: 30 },\n        { x: 15, y: 25 },\n        { x: 10, y: 10 }\n    ],\n    // Drache (Draco)\n    draco: [\n        { x: 5, y: 45 },\n        { x: 10, y: 35 },\n        { x: 15, y: 30 },\n        { x: 20, y: 25 },\n        { x: 25, y: 20 },\n        { x: 30, y: 15 },\n        { x: 35, y: 10 },\n        { x: 30, y: 5 },\n        { x: 20, y: 5 },\n        { x: 10, y: 10 },\n        { x: 5, y: 15 }\n    ],\n    // Zwillinge (Gemini)\n    gemini: [\n        { x: 10, y: 10 },\n        { x: 15, y: 15 },\n        { x: 20, y: 20 },\n        { x: 25, y: 25 },\n        { x: 30, y: 30 },\n        { x: 35, y: 25 },\n        { x: 40, y: 20 },\n        { x: 35, y: 15 },\n        { x: 30, y: 10 }\n    ],\n    // Kreuz des Südens (Southern Cross)\n    southern_cross: [\n        { x: 25, y: 5 },\n        { x: 25, y: 25 },\n        { x: 15, y: 15 },\n        { x: 35, y: 15 }\n    ],\n    // Pegasus (Quadrat)\n    pegasus: [\n        { x: 10, y: 10 },\n        { x: 10, y: 40 },\n        { x: 40, y: 40 },\n        { x: 40, y: 10 },\n        { x: 10, y: 10 }\n    ],\n    // Andromeda\n    andromeda: [\n        { x: 5, y: 10 },\n        { x: 15, y: 15 },\n        { x: 25, y: 17 },\n        { x: 35, y: 15 },\n        { x: 40, y: 5 },\n        { x: 42, y: 12 },\n        { x: 45, y: 20 }\n    ],\n    // Schütze (Sagittarius)\n    sagittarius: [\n        { x: 10, y: 40 },\n        { x: 20, y: 30 },\n        { x: 30, y: 25 },\n        { x: 40, y: 27 },\n        { x: 45, y: 35 },\n        { x: 35, y: 20 },\n        { x: 25, y: 15 },\n        { x: 15, y: 15 }\n    ],\n    // Skorpion (Scorpius)\n    scorpius: [\n        { x: 10, y: 35 },\n        { x: 15, y: 30 },\n        { x: 20, y: 25 },\n        { x: 25, y: 20 },\n        { x: 30, y: 15 },\n        { x: 35, y: 10 },\n        { x: 35, y: 15 },\n        { x: 40, y: 15 },\n        { x: 45, y: 10 },\n        { x: 45, y: 5 }\n    ],\n    // Krebs (Cancer)\n        cancer: [\n            { x: 25, y: 5 },\n            { x: 20, y: 15 },\n            { x: 30, y: 15 },\n            { x: 15, y: 25 },\n            { x: 35, y: 25 },\n            { x: 25, y: 35 }\n        ],     // Fische (Pisces)\n    pisces: [\n        { x: 5, y: 15 },\n        { x: 10, y: 10 },\n        { x: 15, y: 15 },\n        { x: 20, y: 20 },\n        { x: 25, y: 25 },\n        { x: 30, y: 30 },\n        { x: 35, y: 35 },\n        { x: 40, y: 30 },\n        { x: 45, y: 25 },\n        { x: 40, y: 20 },\n        { x: 35, y: 15 }\n    ],\n    // Adler (Aquila)\n    aquila: [\n        { x: 25, y: 5 },\n        { x: 20, y: 15 },\n        { x: 15, y: 25 },\n        { x: 25, y: 20 },\n        { x: 35, y: 25 },\n        { x: 30, y: 15 },\n        { x: 25, y: 5 }\n    ],\n    // Herkules\n    hercules: [\n        { x: 10, y: 10 },\n        { x: 15, y: 25 },\n        { x: 25, y: 30 },\n        { x: 35, y: 25 },\n        { x: 40, y: 10 },\n        { x: 30, y: 15 },\n        { x: 20, y: 15 },\n        { x: 10, y: 10 }\n    ],\n    myrtana: [\n        { x: 40, y: 20 },\n        { x: 36, y: 32 },\n        { x: 25, y: 20 },\n        { x: 10, y: 35 },\n        { x: 18, y: 10 },\n    ]\n};\n// Funktion zur Erstellung von Sternbild-Knoten für beide Algorithmen\nfunction createConstellationNodes(selectedType, count) {\n    const baseNodes = CONSTELLATIONS[selectedType];\n    if (!baseNodes) return [];     \n    let nodes = [];     \n    if (count === baseNodes.length || count <= 0) {\n        // Wenn die Anzahl gleich ist oder keine Anzahl angegeben wurde, \n        // verwenden wir alle Punkte des Sternbilds\n        nodes = baseNodes.map((pt, i) => ({ ...pt, id: i }));\n    } else {\n        // Interpolation für andere Anzahlen\n        const totalSegments = baseNodes.length - 1;\n        for (let i = 0; i < count; i++) {\n            const t = i / (count - 1);\n            const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);\n            const localT = (t * totalSegments) - segment;\n            const p0 = baseNodes[segment];\n            const p1 = baseNodes[segment + 1];\n            const x = p0.x + (p1.x - p0.x) * localT;\n            const y = p0.y + (p1.y - p0.y) * localT;\n            nodes.push({ x: Math.round(x), y: Math.round(y), id: i });\n        }\n    }       \n    return nodes;\n}\n// ================ CHRISTOFIDES ALGORITHMUS ================  \n// Christofides Animation Klasse\nclass ChristofidesAnimation {\n    constructor(canvas, numNodes = 4, startNode = 0) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.scale(canvas.width / 50, canvas.height / 50);\n        this.numNodes = numNodes;\n        this.startNode = startNode;\n        this.nodes = [];\n        this.mstEdges = [];\n        this.oddNodes = [];\n        this.matchingEdges = [];\n        this.eulerianCircuit = [];\n        this.tspPath = [];\n        this.phase = 'mst';\n        this.lastPhase = null;  \n        this.currentMSTIndex = 0;\n        this.currentMatchingIndex = 0;\n        this.currentEulerIndex = 1; \n        this.currentTSPIndex = 1;\n        this.drawnEdges = new Map();\n        this.init();\n        this.drawNodes(true);\n    }\n    // Zeichnet ein Koordinatensystem als Raster\n    drawCoordinateSystem() {\n        this.ctx.strokeStyle = getGridColor();\n        this.ctx.lineWidth = 0.1;\n        for (let x = 0; x <= 50; x += 5) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, 50);\n            this.ctx.stroke();\n        }\n        for (let y = 0; y <= 50; y += 5) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(50, y);\n            this.ctx.stroke();\n        }\n    }       \n    init() {\n        this.generateNodes();\n        this.computeMST();\n        this.findOddNodes();\n        this.computeMatching();\n        this.computeEulerianCircuit();\n        this.computeTSPPath();\n    }     \n    generateNodes() {\n        for (let i = 0; i < this.numNodes; i++) {\n            this.nodes.push({\n                x: Math.floor(Math.random() * (40 - 5 + 1)) + 5,\n                y: Math.floor(Math.random() * (40 - 5 + 1)) + 5,\n                id: i\n            });\n        }\n    }    \n    distance(a, b) {\n        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n    }      \n      computeMST() {\n        const inTree = new Set([this.startNode]);\n        this.mstEdges = [];\n        while (inTree.size < this.numNodes) {\n            let minEdge = null;\n            for (const node of inTree) {\n                for (let i = 0; i < this.numNodes; i++) {\n                    if (!inTree.has(i)) {\n                        const distance = this.distance(this.nodes[node], this.nodes[i]);\n                        if (!minEdge || distance < minEdge.distance) {\n                            minEdge = { from: node, to: i, distance };\n                        }\n                    }\n                }\n            }\n            if (minEdge) {\n                this.mstEdges.push(minEdge);\n                inTree.add(minEdge.to);\n            }\n        }\n    }   \n    findOddNodes() {\n        const degrees = new Array(this.numNodes).fill(0);\n        for (const edge of this.mstEdges) {\n            degrees[edge.from]++;\n            degrees[edge.to]++;\n        }\n        this.oddNodes = degrees.reduce((acc, d, i) => (d % 2 ? [...acc, i] : acc), []);\n    }  \n    computeMatching() {\n        const matchings = this.generateAllMatchings([...this.oddNodes]);\n        let minMatching = null;\n        let minDistance = Infinity;\n        for (const matching of matchings) {\n            const total = matching.reduce((sum, [a, b]) =>\n                sum + this.distance(this.nodes[a], this.nodes[b]), 0);\n            if (total < minDistance) {\n                minDistance = total;\n                minMatching = matching;\n            }\n        }\n        this.matchingEdges = minMatching.map(([a, b]) => ({\n            from: a,\n            to: b,\n            distance: this.distance(this.nodes[a], this.nodes[b])\n        }));\n    }    \n    generateAllMatchings(nodes) {\n        if (nodes.length === 0) return [[]];\n        const [first, ...rest] = nodes;\n        return rest.flatMap((node, i) => {\n            const newRest = rest.filter((_, j) => j !== i);\n            return this.generateAllMatchings(newRest).map(match => [[first, node], ...match]);\n        });\n    }   \n    computeEulerianCircuit() {\n        const adj = new Map();\n        const addEdge = (from, to) => {\n            if (!adj.has(from)) adj.set(from, []);\n            adj.get(from).push(to);\n        };\n        [...this.mstEdges, ...this.matchingEdges].forEach(edge => {\n            addEdge(edge.from, edge.to);\n            addEdge(edge.to, edge.from);\n        });\n        const stack = [this.startNode];\n        const circuit = [];\n        while (stack.length) {\n            let current = stack[stack.length - 1];\n            if (adj.get(current)?.length) {\n                const next = adj.get(current).pop();\n                stack.push(next);\n            } else {\n                circuit.push(stack.pop());\n            }\n        }\n        this.eulerianCircuit = circuit.reverse();\n    }  \n    computeTSPPath() {\n        const visited = new Set();\n        this.tspPath = [];\n        for (const node of this.eulerianCircuit) {\n            if (!visited.has(node)) {\n                visited.add(node);\n                this.tspPath.push(node);\n            }\n        }\n        this.tspPath.push(this.tspPath[0]);\n    } \n    drawNodes(showCoordinateSystem = false) {\n        if (showCoordinateSystem) {\n            this.drawCoordinateSystem();\n        }\n        this.nodes.forEach(node => {\n            this.ctx.beginPath();\n            this.ctx.arc(node.x, node.y, 0.5, 0, Math.PI * 2);\n            this.ctx.fillStyle = getPointColor();\n            this.ctx.fill();\n            this.ctx.font = \"1.5px sans-serif\";\n            this.ctx.fillStyle = getTextColor();\n            this.ctx.textAlign = \"center\";\n            const label = `P${node.id}`;\n            this.ctx.fillText(label, node.x, node.y - 1.2);\n        });\n    }\n    drawEdges(edges, color) {\n        edges.forEach(edge => {\n            const key = [Math.min(edge.from, edge.to), Math.max(edge.from, edge.to)].join('-');\n            let useColor = color;\n            if (this.drawnEdges.has(key) && this.drawnEdges.get(key) === color) {\n                useColor = this.getComplementaryColor(color);\n            }\n            this.ctx.strokeStyle = useColor;\n            this.ctx.lineWidth = 0.3;\n            const from = this.nodes[edge.from];\n            const to = this.nodes[edge.to];\n            this.ctx.beginPath();\n            this.ctx.moveTo(from.x, from.y);\n            this.ctx.lineTo(to.x, to.y);\n            this.ctx.stroke();\n            this.drawnEdges.set(key, useColor);\n        });\n    }   \n    getComplementaryColor(color) {\n        const comp = {\n            \"blue\": \"orange\",\n            \"green\": \"magenta\",\n            \"purple\": \"yellow\",\n            \"orange\": \"blue\"\n        };\n        return comp[color] || \"black\";\n    } \n    highlightOddNodes() {\n        this.oddNodes.forEach(id => {\n            const node = this.nodes[id];\n            this.ctx.beginPath();\n            this.ctx.arc(node.x, node.y, 0.8, 0, Math.PI * 2);\n            this.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n            this.ctx.fill();\n        });\n    }  \n    drawEulerEdge(index) {\n        if (index <= 0 || index >= this.eulerianCircuit.length) return;\n        const from = this.nodes[this.eulerianCircuit[index - 1]];\n        const to = this.nodes[this.eulerianCircuit[index]];\n        this.drawEdges([{ from: this.eulerianCircuit[index - 1], to: this.eulerianCircuit[index] }], 'purple');\n    }   \n    drawTSPPath(index) {\n        if (index <= 0 || index >= this.tspPath.length) return;\n        this.ctx.strokeStyle = 'orange';\n        this.ctx.lineWidth = 0.5;\n        this.ctx.beginPath();\n        const startNode = this.nodes[this.tspPath[0]];\n        this.ctx.moveTo(startNode.x, startNode.y);\n        for (let i = 1; i <= index; i++) {\n            const node = this.nodes[this.tspPath[i]];\n            this.ctx.lineTo(node.x, node.y);\n        }\n        this.ctx.stroke();\n    }   \n    nextStep() {\n        if (this.phase === 'mst') {\n            const edge = this.mstEdges[this.currentMSTIndex];\n            if (edge) {\n                this.drawEdges([edge], 'blue');\n                this.currentMSTIndex++;\n            }\n            if (this.currentMSTIndex >= this.mstEdges.length) {\n                this.phase = 'odd';\n            }\n        }\n        else if (this.phase === 'odd') {\n            this.highlightOddNodes();\n            this.ctx.clearRect(0, 0, 100, 50);\n            this.drawnEdges.clear();\n            this.drawNodes(false);\n            this.highlightOddNodes();\n            this.phase = 'matching';\n        }\n        else if (this.phase === 'matching') {\n            const edge = this.matchingEdges[this.currentMatchingIndex];\n            if (edge) {\n                this.drawEdges([edge], 'green');\n                this.currentMatchingIndex++;\n            }\n            if (this.currentMatchingIndex >= this.matchingEdges.length) {\n                this.phase = 'euler';\n                this.currentEulerIndex = 1;\n            }\n        }\n        else if (this.phase === 'euler') {\n            this.drawEulerEdge(this.currentEulerIndex);\n            this.currentEulerIndex++;\n            if (this.currentEulerIndex >= this.eulerianCircuit.length) {\n                this.phase = 'eulerComplete';\n            }\n        }\n        else if (this.phase === 'eulerComplete') {\n            this.ctx.clearRect(0, 0, 100, 50);\n            this.drawnEdges.clear();\n            this.drawNodes(false);\n            this.highlightOddNodes();\n            this.phase = 'tsp';\n            this.currentTSPIndex = 1;\n        }\n        else if (this.phase === 'tsp') {\n            this.drawTSPPath(this.currentTSPIndex);\n            this.currentTSPIndex++;\n            if (this.currentTSPIndex >= this.tspPath.length) {\n                // Das Koordinatensystem neu zeichnen, wenn die Animation fertig ist\n                this.ctx.clearRect(0, 0, 100, 50);\n                this.drawNodes(true); // true als Parameter, um das Koordinatensystem zu zeichnen\n                this.drawTSPPath(this.tspPath.length - 1); // Finalen Pfad zeichnen\n                stopAutoAnimation();\n            }\n        }\n        updateInfoPanel();\n    }\n} \n// Globale Variablen für Christofides\nlet animation = new ChristofidesAnimation(document.getElementById('canvas'), 4, 0);\nlet autoIntervalId = null; \n// Christofides Funktionen\nfunction updateInfoPanel() {\n    const dataOutput = document.getElementById('dataOutput'); \n    // Aktuelle Phase\n    let html = \"<strong>Aktuelle Phase:</strong> \";\n    const phases = {\n        'mst': 'Minimum Spanning Tree (MST)',\n        'odd': 'Identifikation ungerader Knoten',\n        'matching': 'Minimales perfektes Matching',\n        'euler': 'Euler-Kreis im Multigraphen',\n        'eulerComplete': 'Euler-Kreis komplett',\n        'tsp': 'Hamilton-Kreis durch Shortcutting'\n    };\n    html += phases[animation.phase] || animation.phase.toUpperCase();\n    html += \"<hr>\";     \n    // Punkte\n    html += \"<strong>Generierte Punkte:</strong><br>\";\n    html += animation.nodes.map(node => \"P\" + node.id + \": (\" + node.x + \", \" + node.y + \")\").join(\"<br>\") + \"<hr>\"; \n    // MST Kanten\n    html += \"<strong>MST Kanten:</strong><br>\";\n    if (animation.currentMSTIndex === 0) {\n        html += \"Noch keine MST-Kanten gezeichnet\";\n    } else {\n        html += animation.mstEdges.slice(0, animation.currentMSTIndex)\n            .map(e => \"Von \" + e.from + \" nach \" + e.to + \" (Distanz: \" + e.distance.toFixed(2) + \")\")\n            .join(\"<br>\");\n    }\n    html += \"<hr>\";   \n    // Ungerade Knoten\n    html += \"<strong>Ungerade Knoten:</strong><br>\";\n    if (animation.phase === 'mst' && animation.currentMSTIndex < animation.mstEdges.length) {\n        html += \"Wird nach Fertigstellung des MST berechnet\";\n    } else {\n        html += animation.oddNodes.join(\", \");\n    }\n    html += \"<hr>\"; \n    // Matching Kanten\n    html += \"<strong>Matching Kanten:</strong><br>\";\n    if (animation.phase === 'mst' || animation.phase === 'odd') {\n        html += \"Wird nach Identifikation ungerader Knoten berechnet\";\n    } else if (animation.currentMatchingIndex === 0) {\n        html += \"Noch keine Matching-Kanten gezeichnet\";\n    } else {\n        html += animation.matchingEdges.slice(0, animation.currentMatchingIndex)\n            .map(e => \"Von \" + e.from + \" nach \" + e.to + \" (Distanz: \" + e.distance.toFixed(2) + \")\")\n            .join(\"<br>\");\n    }\n    html += \"<hr>\";  \n    // Eulerischer Pfad\n    html += \"<strong>Eulerischer Pfad:</strong><br>\";\n    if (animation.phase === 'mst' || animation.phase === 'odd' || animation.phase === 'matching') {\n        html += \"Wird nach Abschluss des Matchings berechnet\";\n    } else if (animation.currentEulerIndex <= 1 && animation.phase === 'euler') {\n        html += animation.eulerianCircuit[0];\n    } else {\n        html += animation.eulerianCircuit.slice(0, \n            animation.phase === 'eulerComplete' || animation.phase === 'tsp' ? \n            animation.eulerianCircuit.length : animation.currentEulerIndex).join(\" → \");\n    }\n    html += \"<hr>\"; \n    // TSP Pfad\n    html += \"<strong>TSP Pfad:</strong><br>\";\n    if (animation.phase !== 'tsp') {\n        html += \"Wird im letzten Schritt berechnet\";\n    } else if (animation.currentTSPIndex <= 1) {\n        html += animation.tspPath[0];\n    } else {\n        let path = animation.tspPath.slice(0, animation.currentTSPIndex).join(\" → \");\n        if (animation.currentTSPIndex >= animation.tspPath.length) {\n            let totalLength = 0;\n            for (let i = 1; i < animation.tspPath.length; i++) {\n                totalLength += animation.distance(animation.nodes[animation.tspPath[i-1]], animation.nodes[animation.tspPath[i]]);\n            }\n            path += \"<br><br><span style='font-size: 1.2em;'><strong>Gesamtlänge: \" + totalLength.toFixed(2) + \"</strong></span>\";\n        }\n        html += path;\n    }\n    dataOutput.innerHTML = html;\n}\nfunction nextStep() {\n    if (!animation) return;\n    animation.nextStep();\n}\nfunction startAutoAnimation() {\n    if (autoIntervalId) return;\n    const slider = document.getElementById('speedSlider');\n    const percent = parseInt(slider.value);\n    const speed = 1000 * (100 / percent);\n    autoIntervalId = setInterval(() => {\n        animation.nextStep();\n    }, speed);\n}\nfunction toggleAutoAnimation() {\n    if (autoIntervalId) {\n        stopAutoAnimation();\n    } else {\n        startAutoAnimation();\n    }\n}\nfunction stopAutoAnimation() {\n    if (autoIntervalId) {\n        clearInterval(autoIntervalId);\n        autoIntervalId = null;\n    }\n}\nfunction resetAnimation() {\n    stopAutoAnimation();\n    if (animation) {\n        animation.ctx.clearRect(0, 0, 100, 50);\n        animation.phase = 'mst';\n        animation.lastPhase = null;\n        animation.currentMSTIndex = 0;\n        animation.currentMatchingIndex = 0;\n        animation.currentEulerIndex = 1;\n        animation.currentTSPIndex = 1;\n        animation.drawnEdges.clear();\n        animation.drawNodes(true);\n        updateInfoPanel();\n    }\n}\nfunction updateNumPoints() {\n    stopAutoAnimation();\n    const numPoints = parseInt(document.getElementById('numPoints').value);\n    const startPoint = parseInt(document.getElementById('startPointChristofides').value);\n    animation = new ChristofidesAnimation(document.getElementById('canvas'), numPoints, startPoint);\n    animation.ctx.clearRect(0, 0, 100, 50);\n    animation.drawNodes(true);\n    updateInfoPanel();\n}\nfunction updateStartPoint() {\n    stopAutoAnimation();\n    const startPoint = parseInt(document.getElementById('startPointChristofides').value);       \n    // Prüfen ob der Startpunkt gültig ist\n    if (isNaN(startPoint) || startPoint < 0 || startPoint >= animation.nodes.length) {\n        alert(`Bitte geben Sie einen gültigen Startpunkt zwischen 0 und ${animation.nodes.length - 1} ein.`);\n        return;\n    }      \n    // Speichern der aktuellen Knoten\n    const currentNodes = JSON.parse(JSON.stringify(animation.nodes));     \n    // Erstellen einer neuen Animation mit dem neuen Startpunkt aber den bestehenden Knoten\n    animation = new ChristofidesAnimation(document.getElementById('canvas'), animation.numNodes, startPoint);\n    animation.nodes = currentNodes; // Bestehende Knoten übernehmen     \n    // Berechnen der neuen Pfade mit dem aktuellen Startpunkt\n    animation.mstEdges = [];\n    animation.oddNodes = [];\n    animation.matchingEdges = [];\n    animation.eulerianCircuit = [];\n    animation.tspPath = [];\n    animation.drawnEdges.clear();      \n    // Neuberechnung basierend auf den vorhandenen Knoten\n    animation.computeMST();\n    animation.findOddNodes();\n    animation.computeMatching();\n    animation.computeEulerianCircuit();\n    animation.computeTSPPath();       \n    animation.ctx.clearRect(0, 0, 100, 50);\n    animation.drawNodes(true);\n    updateInfoPanel();\n}\nfunction toggleConstellation(selectedType) {\n    stopAutoAnimation();      \n    if (!selectedType) return; // Wenn keine Auswahl getroffen wurde        \n    animation = new ChristofidesAnimation(document.getElementById('canvas'), 0); // 0, wird überschrieben       \n    // Nutze die gemeinsame Funktion, um die Sternbildknoten zu erstellen\n    // Mit 0 als count werden alle Originalpunkte des Sternbildes verwendet\n    animation.nodes = createConstellationNodes(selectedType, 0);\n    animation.numNodes = animation.nodes.length;        \n    animation.mstEdges = [];\n    animation.oddNodes = [];\n    animation.matchingEdges = [];\n    animation.eulerianCircuit = [];\n    animation.tspPath = [];\n    animation.drawnEdges.clear();       \n    // Neuberechnung\n    animation.computeMST();\n    animation.findOddNodes();\n    animation.computeMatching();\n    animation.computeEulerianCircuit();\n    animation.computeTSPPath();       \n    animation.ctx.clearRect(0, 0, 100, 50);\n    animation.drawNodes(true);\n    updateInfoPanel();       \n    // Aktualisiere das Zahlenfeld mit der tatsächlichen Punktanzahl\n    document.getElementById('numPoints').value = animation.nodes.length;\n}\nfunction downloadGraph() {\n    const canvas = document.getElementById('canvas');\n    const tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = canvas.width;\n    tmpCanvas.height = canvas.height;\n    const tmpCtx = tmpCanvas.getContext('2d');\n    tmpCtx.fillStyle = 'white';\n    tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);\n    tmpCtx.drawImage(canvas, 0, 0);\n    const link = document.createElement('a');\n    link.download = 'graph.png';\n    link.href = tmpCanvas.toDataURL('image/png');\n    link.click();\n}\nfunction drawGraphData() {\n    const dataCanvas = document.getElementById('dataCanvas');\n    if (dataCanvas) {\n        const ctx = dataCanvas.getContext('2d');\n        ctx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, dataCanvas.width, dataCanvas.height);\n        ctx.fillStyle = \"black\";\n        ctx.font = \"14px sans-serif\";\n        const lineHeight = 18;\n        let y = lineHeight;\n        ctx.fillText(\"Graph Daten:\", 10, y);\n        y += lineHeight * 1.5;\n        ctx.fillText(\"Knoten:\", 10, y);\n        y += lineHeight;\n        animation.nodes.forEach(node => {\n            ctx.fillText(`P${node.id}: (${node.x}, ${node.y})`, 10, y);\n            y += lineHeight;\n        });\n    } else {  \n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.save();\n        const textBoxX = canvas.width - 250;\n        const textBoxY = 0;\n        const textBoxWidth = 250;\n        const textBoxHeight = canvas.height;\n        ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\";\n        ctx.fillRect(textBoxX, textBoxY, textBoxWidth, textBoxHeight);\n        ctx.fillStyle = \"black\";\n        ctx.font = \"14px sans-serif\";\n        const lineHeight = 18;\n        let y = textBoxY + lineHeight;\n        ctx.fillText(\"Graph Daten:\", textBoxX + 10, y);\n        y += lineHeight * 1.5;\n        ctx.fillText(\"Knoten:\", textBoxX + 10, y);\n        y += lineHeight;\n        animation.nodes.forEach(node => {\n            ctx.fillText(`P${node.id}: (${node.x}, ${node.y})`, textBoxX + 10, y);\n            y += lineHeight;\n        });\n        ctx.restore();\n    }\n}\nfunction importNNPoints() {\n    if (typeof nnAnimation !== 'undefined' && nnAnimation && nnAnimation.nodes) {\n        stopAutoAnimation();\n        const numPoints = nnAnimation.nodes.length;\n        const startPoint = parseInt(document.getElementById('startPointChristofides').value);\n        animation = new ChristofidesAnimation(document.getElementById('canvas'), numPoints, startPoint);\n        animation.nodes = JSON.parse(JSON.stringify(nnAnimation.nodes));\n        animation.mstEdges = [];\n        animation.oddNodes = [];\n        animation.matchingEdges = [];\n        animation.eulerianCircuit = [];\n        animation.tspPath = [];\n        animation.phase = 'mst';\n        animation.lastPhase = null;\n        animation.currentMSTIndex = 0;\n        animation.currentMatchingIndex = 0;\n        animation.currentEulerIndex = 1;\n        animation.currentTSPIndex = 1;\n        animation.drawnEdges.clear();\n        animation.computeMST();\n        animation.findOddNodes();\n        animation.computeMatching();\n        animation.computeEulerianCircuit();\n        animation.computeTSPPath();\n        animation.ctx.clearRect(0, 0, 100, 50);\n        animation.drawNodes(true);\n        updateInfoPanel();\n    } else {\n        console.log(\"NN-Animation nicht gefunden oder keine Punkte verfügbar\");\n    }\n}\nfunction importBFPoints() {\n    if (typeof bfAnimation !== 'undefined' && bfAnimation && bfAnimation.nodes) {\n        stopAutoAnimation();\n        const numPoints = bfAnimation.nodes.length;\n        const startPoint = parseInt(document.getElementById('startPointChristofides').value);\n        animation = new ChristofidesAnimation(document.getElementById('canvas'), numPoints, startPoint);\n        animation.nodes = JSON.parse(JSON.stringify(bfAnimation.nodes));\n        animation.mstEdges = [];\n        animation.oddNodes = [];\n        animation.matchingEdges = [];\n        animation.eulerianCircuit = [];\n        animation.tspPath = [];\n        animation.phase = 'mst';\n        animation.lastPhase = null;\n        animation.currentMSTIndex = 0;\n        animation.currentMatchingIndex = 0;\n        animation.currentEulerIndex = 1;\n        animation.currentTSPIndex = 1;\n        animation.drawnEdges.clear();\n        animation.computeMST();\n        animation.findOddNodes();\n        animation.computeMatching();\n        animation.computeEulerianCircuit();\n        animation.computeTSPPath();\n        animation.ctx.clearRect(0, 0, 100, 50);\n        animation.drawNodes(true);\n        updateInfoPanel();\n    } else {\n        console.log(\"BF-Animation nicht gefunden oder keine Punkte verfügbar\");\n    }\n}\n// Event-Listener\ndocument.getElementById('speedSlider').addEventListener('input', function() {\n    if (autoIntervalId) {\n        clearInterval(autoIntervalId);\n        const percent = parseInt(this.value);\n        const speed = 1000 * (100 / percent);\n        autoIntervalId = setInterval(() => {\n            animation.nextStep();\n        }, speed);\n    }\n});\n// ================ NEAREST NEIGHBOR ALGORITHMUS ================ \n// Nearest Neighbor Animation Klasse\nclass NearestNeighborAnimation {\n    constructor(canvas, numNodes = 4, startNode = 0) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.scale(canvas.width / 50, canvas.height / 50);\n        this.numNodes = numNodes;\n        this.startNode = startNode;\n        this.nodes = [];\n        this.nnPath = [];\n        this.selectionSteps = []; \n        this.currentPathIndex = 0;    \n        this.init();\n        this.drawNodes(true);\n    }    \n    drawCoordinateSystem() {\n        this.ctx.strokeStyle = getGridColor();\n        this.ctx.lineWidth = 0.1;   \n        for (let x = 0; x <= 100; x += 10) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, 50);\n            this.ctx.stroke();\n        }  \n        for (let y = 0; y <= 50; y += 5) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(100, y);\n            this.ctx.stroke();\n        }\n    }     \n    init() {\n        this.generateNodes();\n        this.computeNearestNeighborPath();\n    }      \n    generateNodes() {\n        for (let i = 0; i < this.numNodes; i++) {\n            this.nodes.push({\n                x: Math.floor(Math.random() * (40 - 5 + 1)) + 5,\n                y: Math.floor(Math.random() * (40 - 5 + 1)) + 5,\n                id: i\n            });\n        }\n    }     \n    distance(a, b) {\n        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n    }       \n    computeNearestNeighborPath() {\n        const visited = new Set([this.startNode]);\n        this.nnPath = [this.startNode]; \n        this.selectionSteps = [];\n        let current = this.startNode;\n        while (visited.size < this.numNodes) {\n            let nearest = null;\n            let minDistance = Infinity;\n            const currentStep = {\n                current: current,\n                candidates: []\n            };\n            for (let i = 0; i < this.numNodes; i++) {\n                if (!visited.has(i)) {\n                    const dist = this.distance(this.nodes[current], this.nodes[i]);\n                    currentStep.candidates.push({\n                        node: i,\n                        distance: dist,\n                        isNearest: false\n                    });\n                    if (dist < minDistance) {\n                        minDistance = dist;\n                        nearest = i;\n                    }\n                }\n            }\n            const nearestCandidate = currentStep.candidates.find(c => c.node === nearest);\n            if (nearestCandidate) {\n                nearestCandidate.isNearest = true;\n            }\n            this.selectionSteps.push(currentStep);\n            current = nearest;\n            visited.add(current);\n            this.nnPath.push(current);\n        } \n        this.nnPath.push(this.startNode);\n    }        \n    drawNodes(showCoordinateSystem = false) {\n        if (showCoordinateSystem) {\n            this.drawCoordinateSystem();\n        }   \n        this.nodes.forEach(node => {\n            this.ctx.beginPath();\n            this.ctx.arc(node.x, node.y, 0.5, 0, Math.PI * 2);\n            this.ctx.fillStyle = getPointColor();\n            this.ctx.fill();\n            this.ctx.font = \"1.5px sans-serif\";\n            this.ctx.fillStyle = getTextColor();\n            this.ctx.textAlign = \"center\";\n            const label = `P${node.id}`;\n            this.ctx.fillText(label, node.x, node.y - 1.2);\n        });\n    }     \n    drawPath(steps) {\n        if (steps <= 0) return;   \n        const pathSegments = Math.min(steps, this.nnPath.length - 1);\n        this.ctx.strokeStyle = 'red';\n        this.ctx.lineWidth = 0.5;\n        this.ctx.beginPath();  \n        const startNode = this.nodes[this.nnPath[0]];\n        this.ctx.moveTo(startNode.x, startNode.y);  \n        for (let i = 1; i <= pathSegments; i++) {\n            const node = this.nodes[this.nnPath[i]];\n            this.ctx.lineTo(node.x, node.y);\n        }  \n        this.ctx.stroke();\n    }     \n    drawSelectionStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= this.selectionSteps.length) return;\n        const step = this.selectionSteps[stepIndex];\n        const currentNode = this.nodes[step.current];\n        this.ctx.beginPath();\n        this.ctx.arc(currentNode.x, currentNode.y, 0.8, 0, Math.PI * 2);\n        this.ctx.fillStyle = 'rgba(0, 128, 255, 0.6)';\n        this.ctx.fill();\n        step.candidates.forEach(candidate => {\n            const candidateNode = this.nodes[candidate.node];\n            this.ctx.strokeStyle = candidate.isNearest ? 'green' : 'blue';\n            this.ctx.lineWidth = candidate.isNearest ? 0.3 : 0.1;\n            this.ctx.setLineDash(candidate.isNearest ? [] : [0.2, 0.2]);\n            this.ctx.beginPath();\n            this.ctx.moveTo(currentNode.x, currentNode.y);\n            this.ctx.lineTo(candidateNode.x, candidateNode.y);\n            this.ctx.stroke();\n            this.ctx.setLineDash([]);\n            if (candidate.isNearest) {\n                this.ctx.beginPath();\n                this.ctx.arc(candidateNode.x, candidateNode.y, 0.8, 0, Math.PI * 2);\n                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';\n                this.ctx.fill();\n            }\n        });\n    }      \n    nextStep() {\n        this.ctx.clearRect(0, 0, 100, 50);\n        this.drawNodes(true);\n        if (this.currentPathIndex < this.selectionSteps.length) {\n            this.drawSelectionStep(this.currentPathIndex);\n            this.drawPath(this.currentPathIndex);\n            this.currentPathIndex++;\n        } else if (this.currentPathIndex === this.selectionSteps.length) {\n            this.drawPath(this.nnPath.length - 1);\n            this.currentPathIndex++;\n        } else {\n            nnStopAutoAnimation();\n        }\n    }   \n    importChristofidesPoints() {\n        if (typeof animation !== 'undefined' && animation && animation.nodes) {\n            this.nodes = JSON.parse(JSON.stringify(animation.nodes));\n            this.numNodes = this.nodes.length;\n            this.computeNearestNeighborPath();\n            this.ctx.clearRect(0, 0, 100, 50);\n            this.currentPathIndex = 0;\n            this.drawNodes(true);\n        }\n    }\n    importBFPoints() {\n        if (typeof bfAnimation !== 'undefined' && bfAnimation && bfAnimation.nodes) {\n            this.nodes = JSON.parse(JSON.stringify(bfAnimation.nodes));\n            this.numNodes = this.nodes.length;\n            this.computeNearestNeighborPath();\n            this.ctx.clearRect(0, 0, 100, 50);\n            this.currentPathIndex = 0;\n            this.drawNodes(true);\n        }\n    }\n} \n// Globale Variablen für Nearest Neighbor\nlet nnAnimation = null;\nlet nnAutoIntervalId = null;   \n// Nearest Neighbor Funktionen\nfunction nnUpdateInfoPanel() {\n    const dataOutput = document.getElementById('nnDataOutput');\n    const stepDropdown = document.getElementById('nnStepDropdown');\n    const stepDetails = document.getElementById('nnStepDetails');\n    const fullTable = document.getElementById('nnFullTable');       \n    if (!dataOutput || !stepDropdown || !nnAnimation) return;        \n    let html = \"<strong>Algorithmus:</strong> Nearest Neighbor<br>\";\n    html += \"<hr>\";\n    html += \"<strong>Punkte:</strong><br>\";\n    html += nnAnimation.nodes.map(node => \"P\" + node.id + \": (\" + node.x + \", \" + node.y + \")\").join(\"<br>\");\n    html += \"<hr>\";       \n    const pathLength = Math.min(nnAnimation.currentPathIndex + 1, nnAnimation.nnPath.length);\n    let path = nnAnimation.nnPath.slice(0, pathLength).map(node => \"P\" + node).join(\" → \");       \n    if (nnAnimation.currentPathIndex >= nnAnimation.selectionSteps.length) {\n        let totalLength = 0;\n        for (let i = 1; i < nnAnimation.nnPath.length; i++) {\n            totalLength += nnAnimation.distance(\n                nnAnimation.nodes[nnAnimation.nnPath[i - 1]], \n                nnAnimation.nodes[nnAnimation.nnPath[i]]\n            );\n        }\n        path += `<br><br><span style='font-size: 1.2em;'><strong>Gesamtlänge: ${totalLength.toFixed(2)}</strong></span>`;\n        // Anzeige des aktuellen Startpunkts\n        path += `<br><strong>Aktueller Startpunkt:</strong> P${nnAnimation.startNode}`;\n    }       \n    html += `<strong>Aktueller Pfad:</strong><br>${path}`;\n    dataOutput.innerHTML = html;        \n    stepDropdown.innerHTML = '<option value=\"\">Schritt auswählen...</option>';\n    nnAnimation.selectionSteps.forEach((step, stepIndex) => {\n        stepDropdown.innerHTML += `<option value=\"${stepIndex}\">Schritt ${stepIndex + 1}: P${step.current}</option>`;\n    });        \n    stepDetails.innerHTML = \"\";        \n    fullTable.style.display = \"none\";\n    fullTable.innerHTML = \"\";\n    \n    // Manuelle Anwendung der Textfarbe für nnDataOutput im Dark Mode\n    if (isDarkMode()) {\n        dataOutput.style.color = getTextColor();\n        const elements = dataOutput.querySelectorAll('*');\n        elements.forEach(el => {\n            if (!el.style.color || el.style.color === \"\") {\n                el.style.color = getTextColor();\n            }\n        });\n    }\n}\nfunction nnShowStepDetails() {\n    const stepDropdown = document.getElementById('nnStepDropdown');\n    const stepDetails = document.getElementById('nnStepDetails');\n    if (!stepDropdown || !stepDetails || !nnAnimation) return;\n    const stepIndex = parseInt(stepDropdown.value);\n    if (isNaN(stepIndex) || stepIndex < 0 || stepIndex >= nnAnimation.selectionSteps.length) {\n        stepDetails.innerHTML = \"\";\n        return;\n    }\n    const step = nnAnimation.selectionSteps[stepIndex];\n    let html = `<strong>Schritt ${stepIndex + 1}:</strong><br>`;\n    html += `<strong>Aktueller Knoten:</strong> P${step.current}<br>`;\n    html += \"<strong>Kandidaten:</strong><br>\";\n    html += \"<ul>\";\n    step.candidates.forEach(candidate => {\n        html += `<li>P${candidate.node}: Entfernung = ${candidate.distance.toFixed(2)} ${\n            candidate.isNearest ? \"(Ausgewählt)\" : \"\"\n        }</li>`;\n    });\n    html += \"</ul>\";\n    stepDetails.innerHTML = html;\n}\nfunction nnShowFullTable() {\n    const fullTableDiv = document.getElementById('nnFullTable');\n    if (!fullTableDiv || !nnAnimation) return;\n    let html = \"<h4></h4>\";\n    html += \"<table class='selection-table' style='width: 100%; border-collapse: collapse;'>\";\n    html += \"<tr><th>Schritt</th><th>Aktueller Knoten</th><th>Kandidat</th><th>Entfernung</th><th>Ausgewählt</th></tr>\";   \n    nnAnimation.selectionSteps.forEach((step, stepIndex) => {\n        step.candidates.forEach(candidate => {\n            html += candidate.isNearest ? \"<tr class='selected'>\" : \"<tr>\";\n            html += `<td style=\"border: 1px solid #ddd; padding: 4px; text-align: center;\">${stepIndex + 1}</td>`;\n            html += `<td style=\"border: 1px solid #ddd; padding: 4px; text-align: center;\">P${step.current}</td>`;\n            html += `<td style=\"border: 1px solid #ddd; padding: 4px; text-align: center;\">P${candidate.node}</td>`;\n            html += `<td style=\"border: 1px solid #ddd; padding: 4px; text-align: center;\">${candidate.distance.toFixed(2)}</td>`;\n            html += `<td style=\"border: 1px solid #ddd; padding: 4px; text-align: center;\">${candidate.isNearest ? \"✓\" : \"\"}</td>`;\n            html += \"</tr>\";\n        });\n    });  \n    html += \"</table>\";      \n    fullTableDiv.innerHTML = html;\n    fullTableDiv.style.display = 'block';\n}\nfunction nnToggleFullTable() {\n    const fullTableDiv = document.getElementById('nnFullTable');\n    if (!fullTableDiv) return;\n    if (fullTableDiv.style.display === 'none' || !fullTableDiv.innerHTML.trim()) {\n        nnShowFullTable();\n    } else {\n        fullTableDiv.style.display = 'none';\n    }\n}\nfunction nnNextStep() {\n    if (!nnAnimation) return;   \n    if (nnAnimation.currentPathIndex > nnAnimation.selectionSteps.length) {\n        nnAnimation.ctx.clearRect(0, 0, 100, 50);\n        nnAnimation.drawNodes(true);\n        nnAnimation.drawPath(nnAnimation.nnPath.length - 1);\n        return;\n    }  \n    nnAnimation.nextStep();   \n    nnUpdateInfoPanel();     \n    if (nnAnimation.currentPathIndex > nnAnimation.selectionSteps.length) {\n        nnAnimation.ctx.clearRect(0, 0, 100, 50);\n        nnAnimation.drawNodes(true);\n        nnAnimation.drawPath(nnAnimation.nnPath.length - 1);       \n        let totalLength = 0;\n        for (let i = 1; i < nnAnimation.nnPath.length; i++) {\n            totalLength += nnAnimation.distance(\n                nnAnimation.nodes[nnAnimation.nnPath[i - 1]], \n                nnAnimation.nodes[nnAnimation.nnPath[i]]\n            );\n        }    \n        nnUpdateInfoPanel();        \n        nnStopAutoAnimation();\n    }\n}\nfunction nnResetAnimation() {\n    nnStopAutoAnimation();\n    if (nnAnimation) {\n        nnAnimation.ctx.clearRect(0, 0, 100, 50);\n        nnAnimation.currentPathIndex = 0;\n        nnAnimation.drawNodes(true);\n        nnUpdateInfoPanel();\n    }\n}\nfunction nnToggleAutoAnimation() {\n    if (nnAutoIntervalId) {\n        nnStopAutoAnimation();\n    } else {\n        nnStartAutoAnimation();\n    }\n}\nfunction nnStartAutoAnimation() {\n    if (nnAutoIntervalId) return;\n    const slider = document.getElementById('nnSpeedSlider');\n    if (!slider) return;\n    const percent = parseInt(slider.value);\n    const speed = 1000 * (100 / percent);\n    nnAutoIntervalId = setInterval(() => {\n        nnNextStep();\n    }, speed);\n}\nfunction nnStopAutoAnimation() {\n    if (nnAutoIntervalId) {\n        clearInterval(nnAutoIntervalId);\n        nnAutoIntervalId = null;\n    }\n}\nfunction nnUpdateNumPoints() {\n    nnStopAutoAnimation();\n    const numPoints = parseInt(document.getElementById('nnNumPoints').value);    \n    if (isNaN(numPoints) || numPoints < 3 || numPoints > 25) {\n        alert(\"Bitte geben Sie eine gültige Anzahl von Punkten zwischen 3 und 25 ein.\");\n        return;\n    }       \n    const startPoint = parseInt(document.getElementById('nnStartPoint').value);\n    nnAnimation = new NearestNeighborAnimation(document.getElementById('nnCanvas'), numPoints, startPoint);    \n    nnAnimation.ctx.clearRect(0, 0, 100, 50);\n    nnAnimation.drawNodes(true);     \n    nnUpdateInfoPanel();\n}\nfunction nnUpdateStartPoint() {\n    nnStopAutoAnimation();\n    const startPoint = parseInt(document.getElementById('nnStartPoint').value);    \n    // Prüfen ob der Startpunkt gültig ist\n    if (isNaN(startPoint) || startPoint < 0 || startPoint >= nnAnimation.nodes.length) {\n        alert(`Bitte geben Sie einen gültigen Startpunkt zwischen 0 und ${nnAnimation.nodes.length - 1} ein.`);\n        return;\n    } \n    // Speichern der aktuellen Knoten\n    const currentNodes = JSON.parse(JSON.stringify(nnAnimation.nodes));     \n    // Erstellen einer neuen Animation mit dem neuen Startpunkt aber den bestehenden Knoten\n    nnAnimation = new NearestNeighborAnimation(document.getElementById('nnCanvas'), nnAnimation.numNodes, startPoint);\n    nnAnimation.nodes = currentNodes; // Bestehende Knoten übernehmen  \n    // Neuberechnung des Nearest-Neighbor-Pfades mit dem neuen Startpunkt\n    nnAnimation.computeNearestNeighborPath(); \n    nnAnimation.ctx.clearRect(0, 0, 100, 50);\n    nnAnimation.drawNodes(true);\n    nnUpdateInfoPanel();\n}\nfunction nnImportPoints() {\n    if (typeof animation !== 'undefined' && animation && animation.nodes) {\n        if (nnAnimation) {\n            nnAnimation.importChristofidesPoints();\n            nnResetAnimation();\n            nnUpdateInfoPanel();\n        }\n    } else {\n        console.log(\"Christofides-Animation nicht gefunden oder keine Punkte verfügbar\");\n    }\n}\nfunction nnImportBFPoints() {\n    if (typeof bfAnimation !== 'undefined' && bfAnimation && bfAnimation.nodes) {\n        if (nnAnimation) {\n            nnAnimation.importBFPoints();\n            nnResetAnimation();\n            nnUpdateInfoPanel();\n        }\n    } else {\n        console.log(\"BF-Animation nicht gefunden oder keine Punkte verfügbar\");\n    }\n}\nfunction nnToggleConstellation(selectedType) {\n    console.log(\"nnToggleConstellation aufgerufen mit:\", selectedType);\n    nnStopAutoAnimation();    \n    if (!selectedType) {\n        console.log(\"Kein Sternenbild ausgewählt\");\n        return;\n    } \n    try {\n        const startPoint = parseInt(document.getElementById('nnStartPoint').value);\n        nnAnimation = new NearestNeighborAnimation(document.getElementById('nnCanvas'), 0, startPoint);\n        console.log(\"Animation erstellt\");\n        nnAnimation.nodes = createConstellationNodes(selectedType, 0);\n        console.log(\"Knoten erzeugt:\", nnAnimation.nodes.length);\n        nnAnimation.numNodes = nnAnimation.nodes.length;\n        nnAnimation.computeNearestNeighborPath();\n        console.log(\"Pfad berechnet\"); \n        nnAnimation.currentPathIndex = 0;\n        nnAnimation.ctx.clearRect(0, 0, 100, 50);\n        nnAnimation.drawNodes(true); \n        nnUpdateInfoPanel();\n        console.log(\"UI aktualisiert\");  \n        document.getElementById('nnNumPoints').value = nnAnimation.nodes.length;\n    } catch (error) {\n        console.error(\"Fehler in nnToggleConstellation:\", error);\n    }\n}\nfunction nnGenerateRandomPoints() {\n    nnStopAutoAnimation();  \n    // Die Anzahl der Punkte aus dem Eingabefeld lesen\n    const numPoints = parseInt(document.getElementById('nnNumPoints').value);\n    // Startpunkt aus dem Eingabefeld lesen\n    const startPoint = parseInt(document.getElementById('nnStartPoint').value);  \n    // Prüfen ob die Anzahl der Punkte gültig ist\n    if (isNaN(numPoints) || numPoints < 3 || numPoints > 25) {\n        alert(\"Bitte geben Sie eine gültige Anzahl von Punkten zwischen 3 und 25 ein.\");\n        return;\n    }   \n    // Neue Animation mit den angegebenen Parametern erstellen\n    nnAnimation = new NearestNeighborAnimation(document.getElementById('nnCanvas'), numPoints, startPoint); \n    // Canvas löschen und neu zeichnen\n    nnAnimation.ctx.clearRect(0, 0, 100, 50);\n    nnAnimation.drawNodes(true);  \n    // Infopanel aktualisieren\n    nnUpdateInfoPanel();\n}\nfunction nnDownloadGraph() {\n    const canvas = document.getElementById('nnCanvas');\n    if (!canvas) return;  \n    const tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = canvas.width;\n    tmpCanvas.height = canvas.height;\n    const tmpCtx = tmpCanvas.getContext('2d'); \n    tmpCtx.fillStyle = 'white';\n    tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);  \n    tmpCtx.drawImage(canvas, 0, 0);  \n    const link = document.createElement('a');\n    link.download = 'nearest-neighbor-graph.png';\n    link.href = tmpCanvas.toDataURL('image/png');\n    link.click();\n} \nfunction nnFindBestStartPoint() {\n    if (!nnAnimation || !nnAnimation.nodes || nnAnimation.nodes.length < 2) return; \n    nnStopAutoAnimation();  \n    // Speichern der aktuellen Knoten\n    const currentNodes = JSON.parse(JSON.stringify(nnAnimation.nodes));\n    const numNodes = currentNodes.length;   \n    // Für jeden möglichen Startpunkt die Tourlänge berechnen\n    let bestStartPoint = 0;\n    let shortestDistance = Infinity;\n    const results = [];   \n    for (let startPoint = 0; startPoint < numNodes; startPoint++) {\n        // Nearest Neighbor Pfad für diesen Startpunkt berechnen\n        const visited = new Set([startPoint]);\n        const path = [startPoint];\n        let current = startPoint;       \n        while (visited.size < numNodes) {\n            let nearest = null;\n            let minDistance = Infinity;\n            \n            for (let i = 0; i < numNodes; i++) {\n                if (!visited.has(i)) {\n                    const dist = nnAnimation.distance(currentNodes[current], currentNodes[i]);\n                    if (dist < minDistance) {\n                        minDistance = dist;\n                        nearest = i;\n                    }\n                }\n            }\n            \n            current = nearest;\n            visited.add(current);\n            path.push(current);\n        }\n        \n        // Gesamtpfadlänge berechnen (einschließlich Rückweg zum Startpunkt)\n        let totalDistance = 0;\n        for (let i = 0; i < path.length - 1; i++) {\n            totalDistance += nnAnimation.distance(\n                currentNodes[path[i]], \n                currentNodes[path[i + 1]]\n            );\n        }\n        // Rückweg zum Startpunkt\n        totalDistance += nnAnimation.distance(\n            currentNodes[path[path.length - 1]], \n            currentNodes[startPoint]\n        );\n        \n        // Pfad und Distanz speichern\n        results.push({\n            startPoint: startPoint,\n            distance: totalDistance,\n            path: [...path, startPoint]\n        });\n        \n        // Prüfen, ob dieser Startpunkt besser ist\n        if (totalDistance < shortestDistance) {\n            shortestDistance = totalDistance;\n            bestStartPoint = startPoint;\n        }\n    }\n    \n    // Sortiere die Ergebnisse nach Pfadlänge\n    results.sort((a, b) => a.distance - b.distance);\n    \n    // Theme-abhängige Farben\n    const isDark = isDarkMode();\n    const bgColor = isDark ? \"#1e3b1e\" : \"#e8ffe8\";\n    const borderColor = isDark ? \"#4CAF50\" : \"#4CAF50\";\n    const textColor = isDark ? \"#fff\" : \"#2E7D32\";\n    const tableHeaderBgColor = isDark ? \"#2a472a\" : \"#d4ffd4\";\n    \n    // Ergebnisanzeige im Panel\n    const dataOutput = document.getElementById('nnDataOutput');\n    if (dataOutput) {\n        let resultHTML = `\n            <div style=\"margin: 15px 0; padding: 15px; background-color: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 5px;\">\n                <h4 style=\"margin-top: 0; color: ${textColor};\">Optimaler Startpunkt gefunden!</h4>\n                <p><strong>Bester Startpunkt:</strong> P${bestStartPoint}</p>\n                <p><strong>Pfadlänge:</strong> ${shortestDistance.toFixed(2)}</p>\n                <p><strong>Optimaler Pfad:</strong> ${results[0].path.map(p => `P${p}`).join(' → ')}</p>\n                <hr>\n                <h5>Alle Startpunkte im Vergleich:</h5>\n                <table class=\"selection-table\" style=\"width: 100%; margin-top: 10px; ${isDark ? 'color: ' + textColor + ';' : ''}\">\n                    <tr>\n                        <th>Rang</th>\n                        <th>Startpunkt</th>\n                        <th>Pfadlänge</th>\n                        <th>Vergleich zum Optimum</th>\n                    </tr>\n        `;\n        \n        // Füge alle Ergebnisse in die Tabelle ein\n        results.forEach((result, index) => {\n            const difference = ((result.distance / shortestDistance - 1) * 100).toFixed(2);\n            const rowClass = result.startPoint === bestStartPoint ? 'selected' : '';\n            const rowStyle = result.startPoint === bestStartPoint && isDark ? \n                `background-color: ${tableHeaderBgColor};` : '';\n            \n            resultHTML += `\n                <tr class=\"${rowClass}\" style=\"${rowStyle}\">\n                    <td style=\"text-align: center;\">${index + 1}</td>\n                    <td style=\"text-align: center;\">P${result.startPoint}</td>\n                    <td style=\"text-align: center;\">${result.distance.toFixed(2)}</td>\n                    <td style=\"text-align: center;\">${index === 0 ? 'Optimum' : '+' + difference + '%'}</td>\n                </tr>\n            `;\n        });\n        \n        resultHTML += `\n                </table>\n            </div>\n        `;\n        \n        dataOutput.innerHTML = resultHTML;\n        \n        // Sicherstellen, dass die Textfarbe im Dark Mode korrekt ist\n        if (isDark) {\n            const resultDiv = dataOutput.querySelector('div');\n            if (resultDiv) {\n                // Alle Text-Elemente in der Tabelle auf die richtige Farbe setzen\n                const textElements = resultDiv.querySelectorAll('p, td, th, h5');\n                textElements.forEach(el => {\n                    if (!el.style.color) {\n                        el.style.color = getTextColor();\n                    }\n                });\n            }\n        }\n    }\n    \n    // Besten Startpunkt in das Eingabefeld setzen\n    document.getElementById('nnStartPoint').value = bestStartPoint;\n    \n    // Animation mit dem besten Startpunkt neu starten\n    nnAnimation = new NearestNeighborAnimation(document.getElementById('nnCanvas'), numNodes, bestStartPoint);\n    nnAnimation.nodes = currentNodes; // Bestehende Knoten übernehmen\n    nnAnimation.computeNearestNeighborPath();\n    nnAnimation.ctx.clearRect(0, 0, 100, 50);\n    nnAnimation.drawNodes(true);\n    nnAnimation.drawPath(nnAnimation.nnPath.length - 1); // Zeige sofort den kompletten optimalen Pfad\n    \n    // Aktualisiere den Fortschritt der Animation, um den vollständigen Pfad anzuzeigen\n    nnAnimation.currentPathIndex = nnAnimation.selectionSteps.length + 1;\n    \n    // Erneut das Theme anwenden für sicheren Dark Mode-Support\n    updateInfoPanelsStyle();\n}\n// Event-Listener\ndocument.getElementById('nnSpeedSlider')?.addEventListener('input', function() {\n    if (nnAutoIntervalId) {\n        clearInterval(nnAutoIntervalId);\n        const percent = parseInt(this.value);\n        const speed = 1000 * (100 / percent);\n        nnAutoIntervalId = setInterval(() => {\n            nnNextStep();\n        }, speed);\n    }\n});\n// Initialisierung beim Laden der Seite\ndocument.addEventListener('DOMContentLoaded', function() {\n    const canvas = document.getElementById('nnCanvas');\n    if (canvas) {\n        nnAnimation = new NearestNeighborAnimation(canvas, 4, 0);\n        nnAnimation.drawNodes(true);\n        nnUpdateInfoPanel();\n    }\n    \n    // Brute Force Animation initialisieren und Info-Panel aktualisieren\n    const bfCanvas = document.getElementById('bfCanvas');\n    if (bfCanvas) {\n        if (bfAnimation) {\n            bfAnimation.updateInfoPanel();\n        } else {\n            bfAnimation = new BruteForceAnimation(bfCanvas, 4, 0);\n            bfAnimation.updateInfoPanel();\n        }\n    }\n});\n// ================ BRUTE FORCE ALGORITHMUS ================\n// Brute Force Animation Klasse\nclass BruteForceAnimation {\n    constructor(canvas, numNodes = 4, startNode = 0) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.scale(canvas.width / 50, canvas.height / 50);\n        this.numNodes = numNodes;\n        this.startNode = startNode;\n        this.nodes = [];\n        this.permutations = [];\n        this.currentPermutationIndex = 0;\n        this.shortestPath = null;\n        this.shortestDistance = Infinity;\n        this.init();\n        this.drawNodes(true);\n        this.updateInfoPanel(); // Info-Panel beim Initialisieren aktualisieren\n    }\n    drawCoordinateSystem() {\n        this.ctx.strokeStyle = getGridColor();\n        this.ctx.lineWidth = 0.1;\n        for (let x = 0; x <= 50; x += 5) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, 50);\n            this.ctx.stroke();\n        }\n        for (let y = 0; y <= 50; y += 5) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(50, y);\n            this.ctx.stroke();\n        }\n    }\n    init() {\n        this.generateNodes();\n        this.permutations = this.generatePermutations([...Array(this.numNodes).keys()]);\n    }\n    generateNodes() {\n        for (let i = 0; i < this.numNodes; i++) {\n            this.nodes.push({\n                x: Math.floor(Math.random() * 40) + 5,\n                y: Math.floor(Math.random() * 40) + 5,\n                id: i\n            });\n        }\n    }\n    generatePermutations(array) {\n        // Wenn ein Startknoten festgelegt ist, generieren wir nur Permutationen, die mit dem Startknoten beginnen\n        const permutations = [];     \n        // Wir fixieren den Startknoten\n        const startNode = this.startNode;       \n        // Entferne den Startknoten aus dem Array\n        const remainingNodes = array.filter(node => node !== startNode);         \n        // Generiere alle Permutationen für die verbleibenden Knoten\n        if (remainingNodes.length === 0) {\n            return [[startNode]];\n        } else if (remainingNodes.length === 1) {\n            return [[startNode, remainingNodes[0]]];\n        }        \n        const restPerms = this.generateAllPermutations(remainingNodes);         \n        // Füge den Startknoten am Anfang jeder Permutation hinzu\n        for (const perm of restPerms) {\n            permutations.push([startNode, ...perm]);\n        }        \n        return permutations;\n    }\n       // Hilfsfunktion zum Generieren aller Permutationen ohne festen Startpunkt\n    generateAllPermutations(array) {\n        if (array.length === 1) return [array];\n        const perms = [];\n        for (let i = 0; i < array.length; i++) {\n            const rest = [...array.slice(0, i), ...array.slice(i + 1)];\n            const restPerms = this.generateAllPermutations(rest);\n            for (const perm of restPerms) {\n                perms.push([array[i], ...perm]);\n            }\n        }\n        return perms;\n    }\n    distance(a, b) {\n        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n    }\n    calculatePathDistance(path) {\n        let distance = 0;\n        for (let i = 0; i < path.length - 1; i++) {\n            distance += this.distance(this.nodes[path[i]], this.nodes[path[i + 1]]);\n        }\n        distance += this.distance(this.nodes[path[path.length - 1]], this.nodes[path[0]]);\n        return distance;\n    }\n    drawNodes(showCoordinateSystem = false) {\n        if (showCoordinateSystem) {\n            this.drawCoordinateSystem();\n        }\n        this.nodes.forEach(node => {\n            this.ctx.beginPath();\n            this.ctx.arc(node.x, node.y, 0.5, 0, Math.PI * 2);\n            this.ctx.fillStyle = getPointColor();\n            this.ctx.fill();\n            this.ctx.font = \"1.5px sans-serif\";\n            this.ctx.fillStyle = getTextColor();\n            this.ctx.textAlign = \"center\";\n            const label = `P${node.id}`;\n            this.ctx.fillText(label, node.x, node.y - 1.2);\n        });\n    }\n    drawPath(path, color = 'blue') {\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = 0.3;\n        this.ctx.beginPath();\n        const startNode = this.nodes[path[0]];\n        this.ctx.moveTo(startNode.x, startNode.y);\n        for (let i = 1; i < path.length; i++) {\n            const node = this.nodes[path[i]];\n            this.ctx.lineTo(node.x, node.y);\n        }\n        this.ctx.lineTo(startNode.x, startNode.y);\n        this.ctx.stroke();\n    }\n    nextStep() {\n        if (this.currentPermutationIndex >= this.permutations.length) {\n            // Wenn alle Permutationen getestet wurden, lösche alle roten Geraden\n            this.ctx.clearRect(0, 0, 50, 50);\n            this.drawNodes(true);\n            // Zeichne nur den kürzesten Pfad in grün\n            if (this.shortestPath) {\n                this.drawPath(this.shortestPath, 'green');\n            }            \n            // Die Punkte und Parameter werden durch die updateInfoPanel-Methode angezeigt\n            this.updateInfoPanel(true);\n            return;\n        }\n        const currentPath = this.permutations[this.currentPermutationIndex];\n        const currentDistance = this.calculatePathDistance(currentPath);\n        if (currentDistance < this.shortestDistance) {\n            this.shortestDistance = currentDistance;\n            this.shortestPath = currentPath;\n        }\n        this.ctx.clearRect(0, 0, 50, 50);\n        this.drawNodes(true);\n        this.drawPath(currentPath, 'red');\n        if (this.shortestPath) {\n            this.drawPath(this.shortestPath, 'green');\n        }\n        this.currentPermutationIndex++;\n        this.updateInfoPanel();\n    }\n    updateInfoPanel(isFinished = false) {\n        const dataOutput = document.getElementById('bfDataOutput');\n        let html = `<strong>Punkte:</strong><br>`;\n        html += this.nodes.map(node => \"P\" + node.id + \": (\" + node.x + \", \" + node.y + \")\").join(\"<br>\");\n        html += \"<hr>\";      \n        html += `<strong>Anzahl der Permutationen:</strong> ${this.permutations.length}<br>`;        \n        if (!isFinished) {\n            html += `<strong>Aktuelle Permutation:</strong> ${this.currentPermutationIndex} von ${this.permutations.length}<br><hr>`;         \n            if (this.currentPermutationIndex < this.permutations.length) {\n                html += `<strong>Aktueller Pfad:</strong> ${this.permutations[this.currentPermutationIndex].map(p => `P${p}`).join(' → ')}<br>`;\n                html += `<strong>Distanz der aktuellen Permutation:</strong> ${this.calculatePathDistance(this.permutations[this.currentPermutationIndex]).toFixed(2)}<br>`;\n            } else {\n                html += \"<strong>Alle Permutationen geprüft</strong><br>\";\n            }\n        } else {\n            html += `<strong>Alle Permutationen geprüft:</strong> ${this.permutations.length} von ${this.permutations.length}<br><hr>`;\n        }          \n        html += `<hr><strong>Kürzeste Distanz:</strong> ${this.shortestDistance !== Infinity ? this.shortestDistance.toFixed(2) : \"Noch nicht gefunden\"}<br>`;           \n        if (this.shortestPath) {\n            html += `<strong>Kürzester Pfad:</strong> ${this.shortestPath.map(p => `P${p}`).join(' → ')}<br>`;        \n            // Zeige detaillierte Ergebnisse an, wenn alle Permutationen geprüft wurden\n            if (isFinished || this.currentPermutationIndex >= this.permutations.length) {\n                html += `<hr><h4>Ergebnisanalyse:</h4>`;  \n                // Berechne Faktoriell für Vergleich\n                const factorial = n => n <= 1 ? 1 : n * factorial(n - 1);\n                const totalPermsWithoutFix = factorial(this.numNodes);\n                const totalPermsWithFix = factorial(this.numNodes - 1);     \n                html += `<strong>Geprüfte Permutationen:</strong> ${this.permutations.length}<br>`;\n                html += `<strong>Gesamtpermutationen ohne festen Startpunkt:</strong> ${totalPermsWithoutFix}<br>`;\n                html += `<strong>Ersparnis durch festen Startpunkt:</strong> ${totalPermsWithoutFix - totalPermsWithFix} Permutationen (${Math.round((1 - totalPermsWithFix/totalPermsWithoutFix) * 100)}%)<br><br>`;      \n                html += `<strong style=\"font-size: 1.2em;\">Gefundener optimaler Pfad:</strong><br>`;\n                html += `<span style=\"font-size: 1.1em;\">${this.shortestPath.map(p => `P${p}`).join(' → ')} → P${this.shortestPath[0]}</span><br>`;\n                html += `<strong>Gesamtlänge:</strong> <span style=\"color: green; font-weight: bold;\">${this.shortestDistance.toFixed(2)}</span><br>`;\n                // Einzelne Wegstücke mit Distanzen anzeigen\n                html += `<br><strong>Einzelne Abschnitte:</strong><br>`;\n                html += `<table class=\"selection-table\" style=\"width: 100%;\">`;\n                html += `<tr><th>Von</th><th>Nach</th><th>Distanz</th></tr>`;\n                // Füge alle Segmente des kürzesten Pfades hinzu\n                for (let i = 0; i < this.shortestPath.length - 1; i++) {\n                    const from = this.shortestPath[i];\n                    const to = this.shortestPath[i + 1];\n                    const dist = this.distance(this.nodes[from], this.nodes[to]);\n                    html += `<tr>\n                        <td style=\"text-align: center;\">P${from}</td>\n                        <td style=\"text-align: center;\">P${to}</td>\n                        <td style=\"text-align: center;\">${dist.toFixed(2)}</td>\n                    </tr>`;\n                }  \n                // Füge den Rückweg zum Startpunkt hinzu\n                const from = this.shortestPath[this.shortestPath.length - 1];\n                const to = this.shortestPath[0];\n                const dist = this.distance(this.nodes[from], this.nodes[to]);\n                html += `<tr>\n                    <td style=\"text-align: center;\">P${from}</td>\n                    <td style=\"text-align: center;\">P${to}</td>\n                    <td style=\"text-align: center;\">${dist.toFixed(2)}</td>\n                </tr>`;     \n                html += `<tr style=\"font-weight: bold;\">\n                    <td colspan=\"2\" style=\"text-align: right;\">Gesamtlänge:</td>\n                    <td style=\"text-align: center;\">${this.shortestDistance.toFixed(2)}</td>\n                </tr>`;\n                html += `</table>`;\n            }\n        } else {\n            html += \"<strong>Kürzester Pfad:</strong> Noch nicht gefunden\";\n        }        \n        dataOutput.innerHTML = html;\n    }\n    reset() {\n        this.currentPermutationIndex = 0;\n        this.shortestPath = null;\n        this.shortestDistance = Infinity;\n        this.ctx.clearRect(0, 0, 50, 50);\n        this.drawNodes(true);\n        this.updateInfoPanel();\n    }\n    importChristofidesPoints() {\n        if (typeof animation !== 'undefined' && animation && animation.nodes) {\n            this.nodes = JSON.parse(JSON.stringify(animation.nodes));\n            this.numNodes = this.nodes.length;\n            this.permutations = this.generatePermutations([...Array(this.numNodes).keys()]);\n            this.reset();\n        }\n    }\n    importNNPoints() {\n        if (typeof nnAnimation !== 'undefined' && nnAnimation && nnAnimation.nodes) {\n            this.nodes = JSON.parse(JSON.stringify(nnAnimation.nodes));\n            this.numNodes = this.nodes.length;\n            this.permutations = this.generatePermutations([...Array(this.numNodes).keys()]);\n            this.reset();\n        }\n    }\n}\nlet bfAnimation = new BruteForceAnimation(document.getElementById('bfCanvas'), 4, 0);\nlet bfAutoIntervalId = null;\nfunction bfNextStep() {\n    if (!bfAnimation) return;\n    bfAnimation.nextStep();\n}\nfunction bfStartAutoAnimation() {\n    if (bfAutoIntervalId) return;\n    const slider = document.getElementById('bfSpeedSlider');\n    const percent = parseInt(slider.value);\n    const speed = 1000 * (100 / percent);\n    bfAutoIntervalId = setInterval(() => {\n        bfAnimation.nextStep();\n    }, speed);\n}\nfunction bfToggleAutoAnimation() {\n    if (bfAutoIntervalId) {\n        bfStopAutoAnimation();\n    } else {\n        bfStartAutoAnimation();\n    }\n}\nfunction bfStopAutoAnimation() {\n    if (bfAutoIntervalId) {\n        clearInterval(bfAutoIntervalId);\n        bfAutoIntervalId = null;\n    }\n}\nfunction bfResetAnimation() {\n    bfStopAutoAnimation();\n    if (bfAnimation) {\n        bfAnimation.reset();\n    }\n}\nfunction bfUpdateNumPoints() {\n    const numPoints = parseInt(document.getElementById('bfNumPoints').value, 10);\n    const startPoint = parseInt(document.getElementById('bfStartPoint').value, 10);\n    if (isNaN(numPoints) || numPoints < 3 || numPoints > 25) {\n        alert(\"Bitte eine gültige Anzahl zwischen 3 und 25 eingeben\");\n        return;\n    }\n    bfAnimation = new BruteForceAnimation(document.getElementById('bfCanvas'), numPoints, startPoint);\n    bfAnimation.reset();\n}\nfunction bfUpdateStartPoint() {\n    bfStopAutoAnimation();\n    const startPoint = parseInt(document.getElementById('bfStartPoint').value);   \n    // Prüfen ob der Startpunkt gültig ist\n    if (isNaN(startPoint) || startPoint < 0 || startPoint >= bfAnimation.nodes.length) {\n        alert(`Bitte geben Sie einen gültigen Startpunkt zwischen 0 und ${bfAnimation.nodes.length - 1} ein.`);\n        return;\n    }    \n    // Speichern der aktuellen Knoten\n    const currentNodes = JSON.parse(JSON.stringify(bfAnimation.nodes));      \n    // Neue Animation mit dem neuen Startpunkt erstellen\n    bfAnimation = new BruteForceAnimation(document.getElementById('bfCanvas'), bfAnimation.numNodes, startPoint);       \n    // Bestehende Knoten übernehmen\n    bfAnimation.nodes = currentNodes;    \n    // Permutationen neu berechnen\n    bfAnimation.permutations = bfAnimation.generatePermutations([...Array(bfAnimation.numNodes).keys()]);     \n    // Animation zurücksetzen\n    bfAnimation.reset();\n}\nfunction bfImportChristofidesPoints() {\n    if (bfAnimation) {\n        bfAnimation.importChristofidesPoints();\n    }\n}\nfunction bfImportNNPoints() {\n    if (bfAnimation) {\n        bfAnimation.importNNPoints();\n    }\n}\nfunction bfToggleConstellation(selectedType) {\n    if (!selectedType) return;\n    // Erstelle eine neue BruteForceAnimation-Instanz\n    bfAnimation = new BruteForceAnimation(document.getElementById('bfCanvas'), 0);\n    // Setze die Knoten basierend auf dem ausgewählten Sternbild\n    bfAnimation.nodes = createConstellationNodes(selectedType, 0);\n    bfAnimation.numNodes = bfAnimation.nodes.length;\n    // Initialisiere die Permutationen und setze die Animation zurück\n    bfAnimation.permutations = bfAnimation.generatePermutations([...Array(bfAnimation.numNodes).keys()]);\n    bfAnimation.reset();\n}\nfunction bfDownloadGraph() {\n    const canvas = document.getElementById('bfCanvas');\n    const tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = canvas.width;\n    tmpCanvas.height = canvas.height;\n    const tmpCtx = tmpCanvas.getContext('2d');\n    tmpCtx.fillStyle = 'white';\n    tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);\n    tmpCtx.drawImage(canvas, 0, 0);\n    const link = document.createElement('a');\n    link.download = 'brute-force-graph.png';\n    link.href = tmpCanvas.toDataURL('image/png');\n    link.click();\n}\nfunction bfShowFullTable() {\n    const fullTableDiv = document.getElementById('bfFullTable');\n    if (!fullTableDiv || !bfAnimation) return;\n    \n    // Theme-abhängige Farben\n    const isDark = isDarkMode();\n    const bgColor = isDark ? \"#2a472a\" : \"#d4ffd4\";\n    const textColor = isDark ? \"#fff\" : \"#000\";\n    const highlightTextColor = isDark ? \"#4CAF50\" : \"#006400\";\n    \n    let html = \"<h4>Alle getesteten Pfade</h4>\";\n    html += \"<table class='selection-table' style='width: 100%; border-collapse: collapse;'>\";\n    html += \"<tr><th>Pfad</th><th>Distanz</th><th>Kürzester Pfad</th></tr>\";\n    \n    bfAnimation.permutations.forEach((path, index) => {\n        const distance = bfAnimation.calculatePathDistance(path).toFixed(2);\n        const isShortest = bfAnimation.shortestPath && bfAnimation.shortestPath.join(',') === path.join(',');\n        \n        // Verbesserte Stilisierung für den kürzesten Pfad\n        const rowStyle = isShortest ? \n            `background-color: ${bgColor}; font-weight: bold;` : '';\n            \n        const checkmarkStyle = isShortest ? \n            `color: ${highlightTextColor}; font-size: 1.2em; font-weight: bold;` : '';\n            \n        html += `<tr style=\"${rowStyle}\" class=\"${isShortest ? 'selected' : ''}\">`;\n        html += `<td style='border: 1px solid #ddd; padding: 4px; text-align: center;'>${path.map(p => `P${p}`).join(' → ')}</td>`;\n        html += `<td style='border: 1px solid #ddd; padding: 4px; text-align: center;'>${distance}</td>`;\n        html += `<td style='border: 1px solid #ddd; padding: 4px; text-align: center; ${checkmarkStyle}'>${isShortest ? \"✓\" : \"\"}</td>`;\n        html += \"</tr>\";\n    });\n    \n    html += \"</table>\";\n    fullTableDiv.innerHTML = html;\n    fullTableDiv.style.display = 'block';\n    \n    // Stelle sicher, dass die Tabellenborden im Dark Mode richtig angezeigt werden\n    if (isDark) {\n        const tableCells = fullTableDiv.querySelectorAll('td, th');\n        tableCells.forEach(cell => {\n            cell.style.borderColor = \"#555\";\n        });\n    }\n}\nfunction bfToggleFullTable() {\n    const fullTableDiv = document.getElementById('bfFullTable');\n    if (!fullTableDiv) return;\n    if (fullTableDiv.style.display === 'none' || !fullTableDiv.innerHTML.trim()) {\n        bfShowFullTable();\n    } else {\n        fullTableDiv.style.display = 'none';\n    }\n}\n</script>\n"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"brute-force-algorithm","depth":3,"text":"Brute Force Algorithm"},{"id":"nearest-neighbor-algorithm","depth":3,"text":"Nearest Neighbor Algorithm"},{"id":"christofides-algorithm","depth":3,"text":"Christofides Algorithm"}]}},"_type":"markdown","_id":"content:articles:5.Algo-vertretung-14-04-25.md","_source":"content","_file":"articles/5.Algo-vertretung-14-04-25.md","_stem":"articles/5.Algo-vertretung-14-04-25","_extension":"md"}